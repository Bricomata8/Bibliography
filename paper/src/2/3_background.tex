\section{Background}

\subsection{Hardware: Zolertia Z1 Motes}

The Z1 is a low power wireless module compliant with IEEE 802.15.4 and Zigbee protocols intended to be used for Wireless Sensor Networks.
This mote has support for Tiny OS,
	Contiki OS,
	OpenWSN and RIOT.
The MCU architecture is based upon the MSP430 and the radio transceiver on CC2420 architecture,
	both from Texas Instruments.

\subsubsection{Peripherals ports}

\paragraph*{North Port}
\paragraph*{East Port}
\paragraph*{South Port}
\paragraph*{West Port}


A Z1 mote has 2 internal sensors,
	and using the external ports,
	can be connected to a variety of external sensors.
The main issue about collecting data with Contiki is the lack of support for floating point numbers in the stdio library,
	because of the large amount of code it requires.
It has floating point numbers,
	but those are only usefull for internal operations.
If a program needs to send the decimal data to an external source,
	has to use integers in the stdio functions,
	to write into the buffers.

\subsubsection{Internal sensors}

\paragraph{Temperature Sensor}

The internal temperature sensor in the Z1 mote is the tmp102 sensor from Texas Instruments.
This sensor is integrated with the z1 motes using the I2C interface.
It can read the temperature range of -40oC to +125oC.
The Contiki OS has his own library of functions that can read the sensor data,
	located in "platform/z1/dev/tmp102.h".
To use it in a program,
	it has to include the library “dev/tmp102.h” 

\paragraph{Accelerometer}
The internal accelerometer in the Z1 motes is the adxl345 from Analog Devices Inc.
This sensor is integrated with the z1 motes using the I2C interface.
The Contiki OS has his own library of functions that can read the sensor data,
	located in "platform/z1/dev/adxl345.h".
To use it in a program,
	it has to include the library “dev/adxl345.h” The sensor has 8 different interrupts to enable and 2 pins for mapping the interrupts.

\subsubsection{External Sensors}
The Z1 motes have several ways to connect sensors.
In the next chapters,
	there are some examples of sensors,
	and how to read the data.

\paragraph{Analog sensors}

To read the analog sensors,
	there is a Contiki library in “platform/z1/dev/z1phidgets.h” This library reads the values of 4 of the pins of the north ports,
	and returns a 16 bit register,
	representing the value.
It uses a 12bits A/D converter,
	so the min value is 0 and the max in 4095.


\subparagraph{Precision Light Sensor}
The precision light sensor used as an example is the Phidget P/N 1127 sensor.
This sensor is an analog sensor that measures light intensities of up to 1000 lux.
It is a non-radiometric sensor.
The output value does not depend on the input voltage,
	but the input voltage will limit the maximum measurement value.
The sensor can be connected to the north port of the Z1 motes,
	into the 3V port or the 5V port.

In Fig.60,
	to read the value of the sensor,
	the phidgets library from Contiki is used.
After a raw read,
	the value is transformed to lux,
	knowing the maximum value of the A/D converter is 4095,
	and the maximum value the sensor can give is 1000 lux.
(In this case is connected to 5V) 


\subparagraph{Force Sensor}

The force sensor used used as an example is the Phidget P/N 1106 sensor.
This force sensor can be used as a button for human input or to sense the presence of a small object.
It is a radiometric sensor.
The output value depends on the input voltage.
It measures the same force value with 3V or 5V.

In Fig. 64,
	to read the value of the sensor,
	the phidgets library from Contiki is used.
Once the raw value is read,
	it is transformed it to Newtons,
	knowing the maximum value of the A/D converter is 4095,
	and the maximum value the sensor can give is 39.2 Newtons.

\subsubsection{Relay actuator}
The relay used as an example is the Electronic brick – 5V Relay form seeedstudio.

This actuator,
	works as a switch,
	when a signal is sent through the signal pin.
It has a library for the Z1 motes in “platform/z1/dev/relay-phidget.h".

This library conflicts with the phidgets library,
	because it turns the selected pin from the north port as an output,
	and the phidgets functions as an input.
In this configuration,
	the switch is powered with 5V supplied by the Z1 in the ON port,
	and with ground in the OFF port.
It toggles the led on and off,
	each time the signal is triggered.

In Fig.68 example,
	the main loop waits for a specified time,
	and then toggles the relay.

\subsubsection{Distance sensor}
The distance sensor used as an example is the SEN-12784 from SparkFun.
It has an VL6180 digital sensor integrated,
	that can read light and distance.
It uses the an I2C interface to extract the values from the sensor registers.

Contiki has a I2C interface library adapter for the Z1 motes in “platform/z1/dev/i2cmater.h” To use it in a program,
	it has to include the library “dev/i2cmaster.h”

The function in Fig.71,
	shows how to read the distance from the device.
It calculates the distance by sending a pulse of light,
	and retrieving it back,
	the doing an internal calculation with the difference between the power of the signal sent and the received.
Between the activation and the collection of the value,
	there is some time waiting for the light to travel.
The functions in Fig.71 and Fig.73,
	show how to set and get a register from the sensor,
	using the I2C interface.




\subsection{Operating systems}




\subsection{Communication protocol}

Wireless sensor networks combines 3 concepts together:
	sensor + CPU + radio.
However,
	combining sensors,
	radio and CPU's together requires an extensive understanding of the hardware components as well as modern networking technologies to connect the devices.
Each node needs to have the necessary tools to send data over the radio channel,
	while meeting the requirements of size,
	cost and power consumption.
The research and development of this kind of devices,
	has been increased over the last years.
There are a number of operating systems focused on providing communications stacks and at the same time focused on saving power.
On the other hand,
	the devices integrating a CPU and a radio transceiver have become more available and efficient.

\subsubsection{Composition}
There are four main types of nodes in a WSN structure.
Sensor nodes:
	These nodes are in charge of collecting data,
	and sending it to the network.
These nodes have 2 parts,
	the sensors board and the mote.
The sensor board,
	contains the sensor to acquire data (light,
	temperature,
	humidity,...) The mote integrates the CPU and the radio transceiver.
Route nodes:
	Nodes with the only purpose of making possible the link between the sensor nodes and the rest of the network.
They work as a repeater of the radio signal,
	and implement routing tasks.
Server station:
	It is the concentrator of the data sent over the network.
It is a node itself,
	or a node attached to a more powerful machine,
	able to manage lots of data.
Gateway:
	Connects the WSN to an external network,
	if needed.

The transmission of sensor's data is done by all the nodes of the network.
Each data packet,
	is sent to the server station hop by hop.
Reducing the transmission power in the nodes,
	may reduce the power consumption on it,
	but it may require a larger number of hops to arrive to the server station 

\subsubsection{RIME}

RIME is a communication stack designed for Contiki.
It provides a hierarchical set of wireless network protocols.
This protocol stack can send data over the standard IEEE 802.14.5 with very few transmissions and less overhead than an IP based protocol,
	saving energy in the devices involved in the connection.
Implementing a complex protocol (say the multi-hop mesh routing) is split into several parts,
	where the more complex modules make use of the simpler ones.


These are some of the different modules of Rime:

\textbf{abc:} the anonymous broadcast,
	it just sends a packet via the radio driver,
	receives all packets from the radio driver and passes them to the upper layer; 
\textbf{broadcast:} the identified broadcast, it adds the sender address to the outgoing
packet and passes it to the abc module;

\textbf{unicast:} this module adds a destination address to the passed packets to the broadcast block.
On the receiver side,
	if the packet's destination address doesn't match the node's address, the packet is discarded;

\textbf{stunicast:} the stubborn unicast,
	when asked to send a packet to a node,
	it sends it repeatedly with a given time period until asked to stop.
This module is usually not used as is,
	but is used by the next one.

\textbf{runicast:} the reliable unicast,
	it sends a packet using the stunicast module waiting for an acknowledgement packet.
When it is received it stops the continuous transmission of the packet.
A maximum retransmission number must be specified,
	in order to avoid infinite sending.

\textbf{polite and ipolite:} these two modules are almost identical,
	when a packet has to be sent in a given time frame,
	the module waits for half of the time,
	checking if it has received the same packet it is about to send.
If it has,
	the packet is not sent,
	otherwise it sends the packet.
This is useful for flooding techniques to avoid unnecessary retransmissions.

\textbf{multihop:} this module requires a route table function,
	and when it is about to send a packet it asks the route table for the next hop and sends the packet to it using unicast.
When it receives a packet,
	if the node is the destination then the packet is passed to the upper layer,
	otherwise it asks again the route table for the next hop and relays the packet to it.































