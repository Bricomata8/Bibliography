\section{Background}

\subsection{Requirements}

\subsection{Hardware: Zolertia Z1 Motes}

The Z1 is a low power wireless module compliant with IEEE 802.15.4 and Zigbee protocols intended to be used for Wireless Sensor Networks.
This mote has support for Tiny OS,
	Contiki OS,
	OpenWSN and RIOT.
The MCU architecture is based upon the MSP430 and the radio transceiver on CC2420 architecture,
	both from Texas Instruments.

\subsubsection{Peripherals ports}

\paragraph{North Port}
\paragraph{East Port}
\paragraph{South Port}
\paragraph{West Port}


A Z1 mote has 2 internal sensors,
	and using the external ports,
	can be connected to a variety of external sensors.
The main issue about collecting data with Contiki is the lack of support for floating point numbers in the stdio library,
	because of the large amount of code it requires.
It has floating point numbers,
	but those are only usefull for internal operations.
If a program needs to send the decimal data to an external source,
	has to use integers in the stdio functions,
	to write into the buffers.


\subsubsection{Internal sensors}

\paragraph{Temperature Sensor}

The internal temperature sensor in the Z1 mote is the tmp102 sensor from Texas Instruments.
This sensor is integrated with the z1 motes using the I2C interface.
It can read the temperature range of -40oC to +125oC.
The Contiki OS has his own library of functions that can read the sensor data,
	located in "platform/z1/dev/tmp102.h".
To use it in a program,
	it has to include the library “dev/tmp102.h” 

\paragraph{Accelerometer}
The internal accelerometer in the Z1 motes is the adxl345 from Analog Devices Inc.
This sensor is integrated with the z1 motes using the I2C interface.
The Contiki OS has his own library of functions that can read the sensor data,
	located in "platform/z1/dev/adxl345.h".
To use it in a program,
	it has to include the library “dev/adxl345.h” The sensor has 8 different interrupts to enable and 2 pins for mapping the interrupts.

\subsubsection{External Sensors}
The Z1 motes have several ways to connect sensors.
In the next chapters,
	there are some examples of sensors,
	and how to read the data.

\paragraph{Analog sensors}

To read the analog sensors,
	there is a Contiki library in “platform/z1/dev/z1phidgets.h” This library reads the values of 4 of the pins of the north ports,
	and returns a 16 bit register,
	representing the value.
It uses a 12bits A/D converter,
	so the min value is 0 and the max in 4095.


\subparagraph{Precision Light Sensor}
The precision light sensor used as an example is the Phidget P/N 1127 sensor.
This sensor is an analog sensor that measures light intensities of up to 1000 lux.
It is a non-radiometric sensor.
The output value does not depend on the input voltage,
	but the input voltage will limit the maximum measurement value.
The sensor can be connected to the north port of the Z1 motes,
	into the 3V port or the 5V port.

In Fig.60,
	to read the value of the sensor,
	the phidgets library from Contiki is used.
After a raw read,
	the value is transformed to lux,
	knowing the maximum value of the A/D converter is 4095,
	and the maximum value the sensor can give is 1000 lux.
(In this case is connected to 5V) 


\subparagraph{Force Sensor}

The force sensor used used as an example is the Phidget P/N 1106 sensor.
This force sensor can be used as a button for human input or to sense the presence of a small object.
It is a radiometric sensor.
The output value depends on the input voltage.
It measures the same force value with 3V or 5V.

In Fig. 64,
	to read the value of the sensor,
	the phidgets library from Contiki is used.
Once the raw value is read,
	it is transformed it to Newtons,
	knowing the maximum value of the A/D converter is 4095,
	and the maximum value the sensor can give is 39.2 Newtons.

\subsubsection{Relay actuator}
The relay used as an example is the Electronic brick – 5V Relay form seeedstudio.

This actuator,
	works as a switch,
	when a signal is sent through the signal pin.
It has a library for the Z1 motes in “platform/z1/dev/relay-phidget.h".

This library conflicts with the phidgets library,
	because it turns the selected pin from the north port as an output,
	and the phidgets functions as an input.
In this configuration,
	the switch is powered with 5V supplied by the Z1 in the ON port,
	and with ground in the OFF port.
It toggles the led on and off,
	each time the signal is triggered.

In Fig.68 example,
	the main loop waits for a specified time,
	and then toggles the relay.

\subsubsection{Distance sensor}
The distance sensor used as an example is the SEN-12784 from SparkFun.
It has an VL6180 digital sensor integrated,
	that can read light and distance.
It uses the an I2C interface to extract the values from the sensor registers.

Contiki has a I2C interface library adapter for the Z1 motes in “platform/z1/dev/i2cmater.h” To use it in a program,
	it has to include the library “dev/i2cmaster.h”

The function in Fig.71,
	shows how to read the distance from the device.
It calculates the distance by sending a pulse of light,
	and retrieving it back,
	the doing an internal calculation with the difference between the power of the signal sent and the received.
Between the activation and the collection of the value,
	there is some time waiting for the light to travel.
The functions in Fig.71 and Fig.73,
	show how to set and get a register from the sensor,
	using the I2C interface.




\subsection{Operating systems}

Contiki is an open source operating system for the Internet of Things.
Contiki connects tiny low-cost,
	low-power micro-controllers to the Internet.

\subsubsection{Main aspects}
2k RAM, 60k ROM; 10k RAM, 48K ROM
Portable to tiny low-power micro-controllers
I386 based, ARM, AVR, MSP430, ...
Implements uIP stack
IPv6 protocol for Wireless Sensor Networks (WSN)
Uses the protothreads abstraction to run multiple process in an event based
kernel.
“Emulates” concurrency
Contiki has an event based kernel (1 stack)
Calls a process when an event happens

\subsubsection{Contiki size}
One of the main aspect of the system,
	is the modularity of the code.
Besides the system core,
	each program builds only the necessary modules to be able to run,
	not the entire system image.
This way,
	the memory used from the system,
	can be reduced to the strictly necessary.
This methodology makes more practical any change in any module,
	if it is needed.
The code size of Contiki is larger than that of TinyOS,
	but smaller than that of the Mantis system.
Contiki's event kernel is significantly larger than that of TinyOS because of the different services provided.
While the TinyOS event kernel only provides a FIFO event queue scheduler ,
	the Contiki kernel supports both FIFO events and poll handlers with priorities.
Furthermore,
	the flexibility in Contiki requires more run-time code than for a system like TinyOS,
	where compile time optimization can be done to a larger extent.

The documentation in the doc folder can be compiled,
	in order to get the html wiki of all the code.
It needs doxygen installed,
	and to run the command “make html”.
This will create a new folder,
	“doc/hmtl”,
	and in the index.html file,
	the wiki can be opened.


\subsubsection{Contiki Hardware}
Contiki can be run in a number of platforms,
	each one with a different CPU.
Tab.7 shows the hardware platforms currently defined in the Contiki code tree.
All these platforms are in the “platform” folder of the code.

\subsubsection{Kernel structure}


\subsection{Communication protocol}

Wireless sensor networks combines 3 concepts together:
	sensor + CPU + radio.
However,
	combining sensors,
	radio and CPU's together requires an extensive understanding of the hardware components as well as modern networking technologies to connect the devices.
Each node needs to have the necessary tools to send data over the radio channel,
	while meeting the requirements of size,
	cost and power consumption.
The research and development of this kind of devices,
	has been increased over the last years.
There are a number of operating systems focused on providing communications stacks and at the same time focused on saving power.
On the other hand,
	the devices integrating a CPU and a radio transceiver have become more available and efficient.

\subsubsection{Composition}
There are four main types of nodes in a WSN structure.
Sensor nodes:
	These nodes are in charge of collecting data,
	and sending it to the network.
These nodes have 2 parts,
	the sensors board and the mote.
The sensor board,
	contains the sensor to acquire data (light,
	temperature,
	humidity,...) The mote integrates the CPU and the radio transceiver.
Route nodes:
	Nodes with the only purpose of making possible the link between the sensor nodes and the rest of the network.
They work as a repeater of the radio signal,
	and implement routing tasks.
Server station:
	It is the concentrator of the data sent over the network.
It is a node itself,
	or a node attached to a more powerful machine,
	able to manage lots of data.
Gateway:
	Connects the WSN to an external network,
	if needed.

The transmission of sensor's data is done by all the nodes of the network.
Each data packet,
	is sent to the server station hop by hop.
Reducing the transmission power in the nodes,
	may reduce the power consumption on it,
	but it may require a larger number of hops to arrive to the server station 


\subsubsection{Physical and MAC Layer (IEEE 802.15.4)}
At present days,
	there are several technology standards.
Each one is designed for a specific need in the market.
For the Wireless Sensor Networks,
	the aim is to transmit little information,
	in a small range,
	with a small power consumption and low cost.
The IEEE 802.15.4 standard offers physical and media access control layers for low-cost,
	low-speed,
	low-power Wireless Personal Area Networks (WPANs)

\paragraph{Physical Layer}
The standard operates in 3 different frequency bands:
- 16 channels in the 2.4GHz ISM band
- 10 channels in the 915MHz ISM band
- 1 channel in the European 868MHz band


\paragraph{Definitions}
Coordinator:
	A device that provides synchronization services through the transmission of beacons.
PAN Coordinator:
	The central coordinator of the PAN.
This device identifies its own network as well as its configurations.
There is only one PAN Coordinator for each network.
Full Function Device (FFD):
	A device that implements the complete protocol set,
	PAN coordinator capable ,
	talks to any other device.
This type of device is suitable for any topology.
Reduced Function Device (RFD):
	A device with a reduced implementation of the protocol,
	cannot become a PAN Coordinator.
This device is limited to leafs in some topologies.

\paragraph{Topologies}
Star topology:
	All nodes communicate via the central PAN coordinator ,
	the leafs may be any combination of FFD and RFD devices.
The PAN coordinator usually uses main power.

Peer to peer topology:
	Nodes can communicate via the central PAN coordinator and via additional point-to-point links .
All devices are FFD to be able to communicate with each other.


Combined Topology:
	Star topology combined with peer-to-peer topology.
Leafs connect to a network via coordinators (FFDs) .
One of the coordinators serves as the PAN coordinator .


\subsubsection{RIME}

RIME is a communication stack designed for Contiki.
It provides a hierarchical set of wireless network protocols.
This protocol stack can send data over the standard IEEE 802.14.5 with very few transmissions and less overhead than an IP based protocol,
	saving energy in the devices involved in the connection.
Implementing a complex protocol (say the multi-hop mesh routing) is split into several parts,
	where the more complex modules make use of the simpler ones.


These are some of the different modules of Rime:

\textbf{abc:} the anonymous broadcast,
	it just sends a packet via the radio driver,
	receives all packets from the radio driver and passes them to the upper layer; 
\textbf{broadcast:} the identified broadcast, it adds the sender address to the outgoing
packet and passes it to the abc module;

\textbf{unicast:} this module adds a destination address to the passed packets to the broadcast block.
On the receiver side,
	if the packet's destination address doesn't match the node's address, the packet is discarded;

\textbf{stunicast:} the stubborn unicast,
	when asked to send a packet to a node,
	it sends it repeatedly with a given time period until asked to stop.
This module is usually not used as is,
	but is used by the next one.

\textbf{runicast:} the reliable unicast,
	it sends a packet using the stunicast module waiting for an acknowledgement packet.
When it is received it stops the continuous transmission of the packet.
A maximum retransmission number must be specified,
	in order to avoid infinite sending.

\textbf{polite and ipolite:} these two modules are almost identical,
	when a packet has to be sent in a given time frame,
	the module waits for half of the time,
	checking if it has received the same packet it is about to send.
If it has,
	the packet is not sent,
	otherwise it sends the packet.
This is useful for flooding techniques to avoid unnecessary retransmissions.

\textbf{multihop:} this module requires a route table function,
	and when it is about to send a packet it asks the route table for the next hop and sends the packet to it using unicast.
When it receives a packet,
	if the node is the destination then the packet is passed to the upper layer,
	otherwise it asks again the route table for the next hop and relays the packet to it.

\subsubsection{6LowPAN}

6LoWPAN is a networking technology or adaptation layer that allows IPv6 packets to be carried efficiently within a small link layer frame,
	over IEEE 802.15.4 based networks.
As the full name implies,
	“IPv6 over Low-Power Wireless Personal Area Networks”,
	it is a protocol for connecting wireless low power networks using IPv6.

As the full name implies,
	“IPv6 over Low-Power Wireless Personal Area Networks”,
	it is a protocol for connecting wireless low power networks using IPv6.

\paragraph{Characteristics}

	\begin{itemize}
		\item Compression of IPv6 and UDP/ICMP headers
		\item Fragmentation / reassembly of IPv6 packets
		\item Mesh addressing
		\item Stateless auto configuration
		\item 
	\end{itemize}
	
\paragraph{Encapsulation Header format}
All LowPAN encapsulated datagrams are prefixed by an encapsulation header stack.
Each header in the stack starts with a header type field followed by zero or more header fields.

\paragraph{Fragment Header}
The fragment header is used when the payload is too large to fit in a single IEEE 802.15.4 frame.
The Fragment header is analogous to the IEEE 1394 Fragment header and includes three fields:
	Datagram Size,
	Datagram Tag,
	and Datagram Offset.
Datagram Size identifies the total size of the unfragmented payload and is included with every fragment to simplify buffer allocation at the receiver when fragments arrive out-oforder.
Datagram Tag identifies the set of fragments that correspond to a given payload and is used to match up fragments of the same payload.
Datagram Offset identifies the fragment’s offset within the unfragmented payload and is in units of 8-byte chunks.

\paragraph{Mesh addressing header}

The Mesh Addressing header is used to forward 6LoWPAN payloads over multiple radio hops and support layer-two forwarding.
The mesh addressing header includes three fields:
	Hop Limit,
	Source Address,
	and Destination Address.
The Hop Limit field is analogous to the IPv6 Hop Limit and limits the number of hops for forwarding.
The Hop Limit field is decremented by each forwarding node,
	and if decremented to zero the frame is dropped.
The source and destination addresses indicate the end-points of an IP hop.
Both addresses are IEEE 802.15.4 link addresses and may carry either a short or extended address.

\paragraph{Header compression (RFC4944)}

RFC 4944 defines HC1,
	a stateless compression scheme optimized for link-local IPv6 communication.
HC1 is identified by an encoding byte following the Compressed IPv6 dispatch header,
	and it operates on fields in the upper-layer headers. 6LoWPAN elides some fields by assuming commonly used values.
For example,
	it compresses the 64-bit network prefix for both source and destination addresses to a single bit each when they carry the well-known link-local prefix. 6LoWPAN compresses the Next Header field to two bits whenever the packet uses UDP,
	TCP,
	or ICMPv6.
Furthermore, 6LoWPAN compresses Traffic Class and Flow Label to a single bit when their values are both zero.
Each compressed form has reserved values that indicate that the fields are carried inline for use when they don’t match the elided case.
6LoWPAN elides other fields by exploiting cross-layer redundancy.
It can derive Payload Length – which is always elided – from the 802.15.4 frame or 6LoWPAN fragmentation header.
The 64-bit interface identifier (IID) for both source and destination addresses are elided if the destination can derive them from the corresponding link-layer address in the 802.15.4 or mesh addressing header.
Finally, 6LoWPAN always elides Version by communicating via IPv6.

The HC1 encoding is shown in Figure 11.
The first byte is the dispatch byte and indicates the use of HC1.
Following the dispatch byte are 8 bits that identify how the IPv6 fields are compressed.
For each address,
	one bit is used to indicate if the IPv6 prefix is linklocal and elided and one bit is used to indicate if the IID can be derived from the IEEE 802.15.4 link address.
The TF bit indicates whether Traffic Class and Flow Label are both zero and elided.
The two Next Header bits indicate if the IPv6 Next Header value is 7UDP,
	TCP,
	or ICMP and compressed or carried inline.
The HC2 bit indicates if the next header is compressed using HC2.
Fully compressed,
	the HC1 encoding reduces the IPv6 header to three bytes,
	including the dispatch header.
Hops Left is the only field always carried inline.


RFC 4944 uses stateless compression techniques to reduce the overhead of UDP headers.
When the HC2 bit is set in the HC1 encoding,
	an additional 8-bits is included immediately following the HC1 encoding bits that specify how the UDP header is compressed.
To effectively compress UDP ports, 6LoWPAN introduces a range of wellknown ports (61616 – 61631).
When ports fall in the well-known range,
	the upper 12 bits may be elided.
If both ports fall within range,
	both Source and Destination ports are compressed down to a single byte.
HC2 also allows elision of the UDP Length,
	as it can be derived from the IPv6 Payload Length field.

The best-case compression efficiency occurs with link-local unicast communication,
	where HC1 and HC2 can compress a UDP/IPv6 header down to 7 bytes.
The Version,
	Traffic Class,
	Flow Label,
	Payload Length,
	Next Header,
	and linklocal prefixes for the IPv6 Source and Destination addresses are all elided.
The suffix for both IPv6 source and destination addresses are derived from the IEEE 802.15.4 header.

However,
	RFC 4944 does not efficiently compress headers when communicating outside of link-local scope or when using multicast.
Any prefix other than the linklocal prefix must be carried inline.
Any suffix must be at least 64 bits when carried inline even if derived from a short 802.15.4 address.
As shown in Figure 8,
	HC1/HC2 can compress a link-local multicast UDP/IPv6 header down to 23 bytes in the best case.
When communicating with nodes outside the LoWPAN,
	the IPv6 Source Address prefix and full IPv6 Destination Address must be carried inline.

\paragraph{Header compression Improved (draft-hui-6lowpan-hc-01)}

To provide better compression over a broader range of scenarios,
	the 6LoWPAN working group is standardizing an improved header compression encoding format,
	called HC.
The format defines a new encoding for compressing IPv6 header,
	called IPHC.
The new format allows Traffic Class and Flow Label to be individually compressed,
	Hop Limit compression when common values (E.g., 1 or 255) are used,
	makes use of shared-context to elide the prefix from IPv6 addresses,
	and supports multicast addresses most often used for IPv6 ND and SLAAC.
Contexts act as shared state for all nodes within the LoWPAN.
A single context holds a single prefix.
IPHC identifies the context using a 4-bit index,
	allowing IPHC to support up to 16 contexts simultaneously within the LoWPAN.
When an IPv6 address matches a context’s stored prefix,
	IPHC compresses the prefix to the context’s 4-bit identifier.
Note that contexts are not limited to prefixes assigned to the LoWPAN but can contain any arbitrary prefix.
As a result,
	share contexts can be configured such that LoWPAN nodes can compress the prefix in both Source and Destination addresses even when communicating with nodes outside the LoWPAN.

The improved header compression encoding is shown in Figure 8.
The first three bits (011) form the header type and indicate the use of IPHC.
The TF bits indicate whether the Traffic Class and/or Flow Label fields are compressed.
The HLIM bits indicate whether the Hop Limit takes the value 1 or 255 and compressed,
	or carried inline.

Bits 8-15 of the IPHC encoding indicate the compression methods used for the IPv6 Source and Destination Addresses.
When the Context Identifier (CID) bit is zero,
	the default context may be used to compress Source and/or Destination Addresses.
This mode is typically when both Source and Destination Addresses are assigned to nodes in the same LoWPAN.
When the CID bit is one,
	two additional 4-bit fields follow the IPHC encoding to indicate which one of 16 contexts is in use for the source and destination addresses.
The Source Address Compression (SAC) indicates whether stateless compression is used (typically for link-local communication) or stateful context-based compression is used (typically for global communication).
The Source Address Mode (SAM) indicates whether the full Source Address is carried inline,
	upper 16 or 64-bits are elided,
	or the full Source Address is elided.
When SAC is set and the Source Addresses’ prefix is elided,
	the identified context is used to restore those bits.
The Multicast (M) field indicates whether the Destination Address is a unicast or multicast address.
When the Destination Address is a unicast address,
	the DAC and DAM bits are analogous to the SAC and SAM bits.
When the Destination Address is a multicast address,
	the DAM bits indicate different forms of multicast compression.
HC also defines a new framework for compressing arbitrary next headers,
	called NHC.
HC2 in RFC 4944 is only capable of compressing UDP,
	TCP,
	and ICMPv6 headers,
	the latter two are not yet defined.
Instead,
	the NHC header defines a new variable length Next Header identifier,
	allowing for future definition of arbitrary next header compression encodings.
HC initially defines a compression encoding for UDP headers,
	similar to that defined in RFC 4944.
Like RFC 4944,
	HC utilizes the same well-known port range (61616-61631) to effectively compress UDP ports down to 4-bits each in the best case.
However,
	HC no longer provides an option to carry the Payload Length in line,
	as it can always be derived from the IPv6 header.
Finally,
	HC allows elision of the UDP Checksum whenever an 10upper layer message integrity check covers the same information and has at least the same strength.
Such a scenario is typical when transportor application-layer security is used.
As a result,
	the UDP header can be compressed down to two bytes in the best case.


\subsubsection{RPL}
RPL is a Distance Vector IPv6 routing protocol for LLNs that specifies how to build a Destination Oriented Directed Acyclic Graph (DODAG) using an objective function and a set of metrics/constraints.
The objective function operates on a combination of metrics and constraints to compute the ‘best’ path.

An RPL Instance consists of multiple Destination Oriented Directed Acyclic Graphs (DODAGs).
Traffic moves either up towards the DODAG root or down towards the DODAG leafs.
The graph building process starts at the root or LBR (LowPAN Border Router).
There could be multiple roots configured in the system.
The RPL routing protocol specifies a set of ICMPv6 control messages to exchange graph related information.
These messages are called DIS (DODAG Information Solicitation),
	DIO (DODAG Information Object) and DAO (DODAG Destination Advertisement Object).
The root starts advertising the information about the graph using the DIO message.
The nodes in the listening vicinity (neighbouring nodes) of the root will receive and process DIO messages potentially from multiple nodes and makes a decision based on certain rules (according to the objective function,
	DAG characteristics,
	advertised path cost and potentially local policy) whether to join the graph or not.
Once the node has joined a graph it has a route toward the graph (DODAG) root.
The graph root is termed as the ‘parent’ of the node.
The node computes the ‘rank’ of itself within the graph,
	which indicates the “coordinates” of the node in the graph hierarchy.
If configured to act as a router,
	it starts advertising the graph information with the new information to its neighbouring peers.
If the node is a “leaf node”,
	it simply joins the graph and does not send any DIO message.
The neighbouring peers will repeat this process and do parent selection,
	route addition and graph information advertisement using DIO messages.
This rippling effect builds the graph edges out from the root to the leaf nodes where the process terminates.
In this formation each node of the graph has a routing entry towards its parent (or multiple parents depending on the objective function) in a hop-by-hop fashion and the leaf nodes can send a data packet all the way to root of the graph by just forwarding the packet to its immediate parent.
This model represents a MP2P (Multipoint-to-point) forwarding model where each node of the graph has reach-ability toward the graph root.
This is also referred to as UPWARD routing.
Each node in the graph has a ‘rank’ that is relative and represents an increasing coordinate of the relative position of the node with respect to the root in graph topology.
The notion of “rank” is used by RPL for various purposes including loop avoidance.
The MP2P flow of traffic is called the ‘up’ direction in the DODAG.


The DIS message is used by the nodes to proactively solicit graph information (via DIO) from the neighbouring nodes should it become active in a stable graph environment using the ‘poll’ or ‘pull’ model of retrieving graph information or in other conditions.
Similar to MP2P or ‘up’ direction of traffic,
	which flows from the leaf towards the root there is a need for traffic to flow in the opposite or ‘down’ direction.
This traffic may originate from outside the LLN network,
	at the root or at any intermediate nodes and destined to a (leaf) node.
This requires a routing state to be built at every node and a mechanism to populate these routes.
This is accomplished by the DAO (Destination Advertisement Object) message.
DAO messages are used to advertise prefix reachability towards the leaf nodes in support of the ‘down’ traffic.
These messages carry prefix information,
	valid lifetime and other information about the distance of the prefix.
As each node joins the graph it will send DAO message to its parent set.
Alternately,
	a node or root can poll the sub-dag for DAO message through an indication in the DIO message.
As each node receives the DAO message,
	it processes the prefix information and adds a routing entry in the routing table.
It optionally aggregates the prefix information received from various nodes in the subdag and sends a DAO message to its parent set.
This process continues until the prefix information reaches the root and a complete path to the prefix is setup.
Note that this mode is called the “storing” mode of operation where intermediate nodes have available memory to store routing tables.
RPL also supports another mode called “non-storing” mode where intermediate node do not store any routes.


\subsection{Application protocol}

\subsubsection{COAP (COnstrained Application Protocol)}

The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained networks in the Internet of Things.
More detailed information about the protocol is given in the Contiki OS CoAP section.

\paragraph{Overview}
Like HTTP,
	CoAP is a document transfer protocol.
Unlike HTTP,
	CoAP is designed for the needs of constrained devices.
The packets are much smaller than HTTP TCP flows.
Packets are simple to generate and can be parsed in place without consuming extra RAM in constrained devices.
CoAP runs over UDP,
	not TCP.
Clients and servers communicate through connectionless datagrams.
Retries and reordering are implemented in the application stack.
It follows a client/server model.
Clients make requests to servers,
	servers send back responses.
Clients may GET,
	PUT,
	POST and DELETE resources.
CoAP implements the REST model from HTTP,
	with the primitives GET,
	POST,
	PUT and DELETE.

\paragraph{Coap Methods}
CoAP extends the HTTP request model with the ability to observe a resource.
When the observe flag is set on a CoAP GET request,
	the server may continue to reply after the initial document has been transferred. This allows servers to stream state
	changes to clients as they occur. Either end may cancel the observation.
	CoAP defines a standard mechanism for resource discovery. Servers provide a list
	of their resources (along with metadata about them) at /.well-known/core. These links
	are in the application/link-format media type and allow a client to discover what
	resources are provided and what media types they are.

\paragraph{Coap Transactions}

\paragraph{Coap Messages}
The CoAP message structure is designed to be simpler than HTTP,
	for reduced transmission data.
Each field responds to a specific purpose.


\subsection{Workspace ant tools}




































