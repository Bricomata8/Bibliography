\section{IoT Hardware and software platforms}

\subsection{Software platform: Operating systems}

The operating system is the foundation of the IoT technology as it provides the functions for the connectivity between the nodes.
However,
	different types of nodes need different levels of OS complexity;
	a passive node generally only needs the communication stack and is not in need of any threading capabilities,
	as the program can handle all logic in one function.
Active nodes and border routers need to have a much more complex OS,
	as they need to be able to handle several running threads or processes,
	e.g.
routing,
	data collection and interrupts.
To qualify as an OS suitable for the IoT,
	it needs to meet the basic requirements:
	• Low Random-access memory (RAM) footprint 
	• Low Read-only memory (ROM) footprint 
	• Multi-tasking • Power management (PM) 
	• Soft real-time These requirements are directly bound to the type of hardware designed for the IoT.
As this type of hardware in general needs to have a small form factor and a long battery life,
	the on-board memory is usually limited to keep down size and energy consumption.
Also,
	because of the limited amount of memory,
	the implementation of threads is usually a challenging task,
	as context switching needs to store thread or process variables to memory.
The size of the memory also directly affects the energy consumption,
	as memory in general is very power hungry during accesses.
To be able reduce the energy consumption,
	the OS needs some kind of power management.
The power management does not only let the OS turn on and off peripherals such as flash memory,
	I/O,
	and sensors,
	but also puts the MCU itself in different power modes.
As the nodes can be used to control and monitor consumer devices,
	either a hard or soft real-time OS is required.
Otherwise,
	actions requiring a close to instantaneous reaction might be indefinitely delayed.
Hard real-time means that the OS scheduler can guarantee latency and execution time,
	whereas Soft real-time means that latency and execution time is seen as real-time but can not be guaranteed by the scheduler.
Operating systems that meet the above requirements are compared in table 2.1 and 2.2.

\begin{table}[h!]
\begin{tabular}{l|l|c|l|c|c|l|l} % Application protocol
	\bf{OS}      & \bf{Architecture} & \bf{Multi}     & \bf{Scheduling} & \bf{Dynamic}    & \bf{Memory}     & \bf{Network}  & \bf{Virtualization} \\
	\            &                   & \bf{threading} &                 & \bf{Memory}     & \bf{protection} & \bf{Stack} & \bf{and Completion}   \\\hline
	\bf{Contiki/Contiki-ng} & Modular& \ok            & Interrupts      & \ok             & \ko             & uIP          & Serialized          \\
	\            &                   &                & execute w.r.t.  &                 &                 & Rime         & Access              \\\hline
	\bf{MANTIS}  & Modular           & \ko            & Priority        & \ok             & \ko             & At Kernel    & Semaphores.         \\
	\            &                   &                & classes         &                 &                 & COMM layer   &                     \\\hline
	\bf{Nano-RK} & Layered           & \ok            & Monotonic       & \ko             & \ko             & Socket       & Serialized access   \\
	\            &                   &                & harmonized      &                 &                 & abstraction  & semaphores          \\\hline
	\bf{LiteOS}  & Monolithic        & \ok            & Round Robin     & \ok             & \ok             & File         & Synchronization     \\
	\            &                   &                &                 &                 &                 &              & primitives          \\\hline
\end{tabular}
\caption{\label{tab:OS} Common operating systems used in IoT environment \cite{al-fuqaha_internet_24}}
\end{table}

\subsubsection{Contiki}
Contiki is a embedded operating system developed for IoT written in C [12].
It supports a broad range of MCUs and has drivers for various transceivers.
The OS does not only support TCP/IPv4 and IPv6 with the uIP stack [9],
	but also has support for the 6LoWPAN stack and its own stack called RIME.
It supports threading with a thread system called Photothreads [13].
The threads are stack-less and thus use only two bytes of memory per thread;
	however,
	each thread is bound to one function and it only has permission to control its own execution.
Included in Contiki,
	there is a range of applications such as a HTTP,
	Constrained Application Protocol (CoAP),
	FTP,
	and DHCP servers,
	as well as other useful programs and tools.
These applications can be included in a project and can run simultaneously with the help of Photothreads.
The limitations to what applications can be run is the amount of RAM and ROM the target MCU provides.
A standard system with IPv6 networking needs about 10 kB RAM and 30 kB ROM but as applications are added the requirements tend to grow.

\subsubsection{RIOT}
RIOT is a open source embedded operating system supported by Freie Universität Berlin,
	INIRA,
	and Hamburg University of Applied Sciences [14].
The kernel is written in C but the upper layers support C++ as well.
As the project originates from a project with real-time and reliability requirements,
	the kernel supports hard real-time multi-tasking scheduling.
One of the goals of the project is to make the OS completely POSIX compliant.
Overhead for multi-threading is minimal with less than 25 bytes per thread.
Both IPv6 and 6LoWPAN is supported together with UDP,
	TCP,
	and IPv6 Routing Protocol for Low-Power and Lossy Networks (RPL);
	and CoAP and Concise Binary Object Representation (CBOR) are available as application level communication protocols.

\subsubsection{TinyOS}
TinyOS is written in Network Embedded Systems C (nesC) which is a variant of C [15].
nesC does not have any dynamic memory allocation and all program paths are available at compile-time.
This is manageable thanks to the structure of the language;
	it uses modules and interfaces instead of functions [16].
The modules use and provide interfaces and are interconnected with configurations;
	this procedure makes up the structure of the program.
Multitasking is implemented in two ways:
	trough tasks and events.
Tasks,
	which focus on computation,
	are non-preemptive,
	and run until completion.
In contrast,
	events which focus on external events i.e.
interrupts,
	are preemptive,
	and have separate start and stop functions.
The OS has full support for both 6LoWPAN and RPL,
	and also have libraries for CoAP.


\subsubsection{freeRTOS}
One of the more popular and widely known operating systems is freeRTOS [17].
Written in C with only a few source files,
	it is a simple but powerful OS,
	easy to overview and extend.
It features two modes of scheduling,
	pre-emptive and co-operative,
	which may be selected according to the requirements of the application.
Two types of multitasking are featured:
	one is a lightweight Co-routine type,
	which has a shared stack for lower RAM usage and is thus aimed to be used on very small devices;
	the other is simply called Task,
	has its own stack and can therefore be fully pre-empted.
Tasks also support priorities which are used together with the pre-emptive scheduler.
The communication methods supported out-of-the-box are TCP and UDP.

\subsection{Hardware platform}

Even though the hardware is in one sense the tool that the OS uses to make IoT possible,
	it is still very important to select a platform that is future-proof and extensible.
To be regarded as an extensible platform,
	the hardware needs to have I/O connections that can be used by external peripherals.
Amongst the candidate interfaces are Serial Peripheral Interface (SPI),
	Inter-Integrated Circuit (I 2 C),
	and Controller Area Network (CAN).
These interfaces allow developers to attach custom-made PCBs with sensors for monitoring or actuators for controlling the environment.
The best practice is to implement an extension socket with a well-known form factor.
A future-proof device is specified as a device that will be as attractive in the future as it is today.
For hardware,
	this is very hard to achieve as there is constant development that follows Moore’s Law [4];
	however,
	the most important aspects are:
	the age of the chip,
	its expected remaining lifetime,
	and number of current implementations i.e.
its popularity.
If a device is widely used by consumers,
	the lifetime of the product is likely to be extended.
One last thing to take into consideration is the product family;
	if the chip belongs to a family with several members the transition to a newer chip is usually easier.

\subsubsection{OpenMote}

OpenMote is based on the Ti CC2538 System on Chip (SoC),
	which combines an ARM Cortex-M3 with a IEEE 802.15.4 transceiver in one chip [18, 19].
The board follows the XBee form factor for easier extensibility,
	which is used to connect the core board to either the OpenBattery or OpenBase extension boards [20, 21].
It originates from the CC2538DK which was used by Thingsquare to demo their Mist IoT solution [22].
Hence,
	the board has full support for Contiki,
	which is the foundation of Thingsquare.
It can run both as a battery-powered sensor board and as a border router,
	depending on what extension board it is attached to,
	e.g OpenBattery or OpenBase.
Furthermore,
	the board has limited support but ongoing development for RIOT and also full support for freeRTOS.

\subsubsection{MSB430-H}

The Modular Sensor Board 430-H from Freie Universität Berlin was designed for their ScatterWeb project [23].
As the university also hosts the RIOT project,
	the decision to support RIOT was natural.
The main board has a Ti MSP430F1612 MCU [24],
	a \textbf{Ti CC1100 transceiver},
	and a battery slot for dual AA batteries;
	it also includes a SHT11 temperature and humidity sensor and a MMA7260Q accelerometer to speed up early development.
All GPIO pins and buses are connected to external pins for extensibility.
Other modules with new peripherals can then be added by making a PCB that matches the external pin layout.

\subsubsection{Zolertia}
As many other Wireless Sensor Network (WSN) products,
	the Zolertia Z1 builds upon the MSP430 MCU [25, 26].
The communication is managed by the Ti CC2420 which operates in the 2.4 GHz band.
The platform includes two sensors:
	the SHT11 temperature and humidity sensor and the MMA7600Q accelerometer.
Extensibility is ensured with:
	two connections designed especially for external sensors,
	an external connector with USB,
	Universal asynchronous \textbf{receiver/transmitter (UART)},
	SPI,
	and I 2 C.

\subsection{Communication protocol}

Several different wireless communication protocols,
	such as Wireless LAN (WLAN),
	BLE, 6LoWPAN,
	and ZigBee may be suitable for IoT applications.
They all operate in the 2.4GHz frequency band and this,
	together with the limited output power in this band,
	means that they all have a similar range.
The main differences are located in the MAC,
	PHY,
	and network layer.
WLAN is much too power hungry as seen in table 2.6 and is only listed as a reference for the comparisons.


\subsubsection{IEEE 802.15.4}
The IEEE 802.15.4 standard defines the PHY and MAC layers for wireless communication [6].
It is designed to use as little transmission time as possible but still have a decent payload,
	while consuming as little power as possible.
Each frame starts with a preamble and a start frame delimiter;
	it then continues with the MAC frame length and the MAC frame itself as seen in figure 2.2.
The overhead for each PHY packet is only 4+1+1 133 tild 4.5\%;
	when
using the maximum transmission speed of 250kbit/s,
	each frame can be sent 133byte in 250kbit/s = 4.265ms.
Furthermore,
	it can also operate in the 868MHz and 915MHz bands,
	maintaining the 250kbit/s transmission rate by using Offset quadrature phase-shift keying (O-QPSK).

Several network layer protocols are implemented on top of IEEE 802.15.4.
The two that will be examined are 6LoWPAN and ZigBEE.

\paragraph{6LoWPAN} 
is a relatively new protocol that is maintained by the Internet
Engineering Task Force (IETF) [7, 6].
The purpose of the protocol is to enable IPv6 traffic over a IEEE 802.15.4 network with as low overhead as possible;
	this is achieved by compressing the IPv6 and UDP header.
A full size IPv6 + UDP header is 40+8 bytes which is tild 38\% of a IEEE 802.15.4
frame,
	but with the header compression this overhead can be reduced to 7 bytes,
	thus reducing the overhead to tild 5\%,
	as seen in figures 2.3 and 2.4.

\paragraph{ZigBee} 
is a communication standard initially developed for home automation
networks; it has several different protocols designed for specific areas such
as lighting, remote control, or health care [27, 6]. Each of these protocols
uses their own addressing with different overhead; however, there is also the
possibility of direct IPv6 addressing. Then, the overhead is the same as for
uncompressed 6LoWPAN, as seen in figure 2.5.

A new standard called ZigBee 3.0 aims to bring all these standards together under one roof to simplify the integration into IoT.
The release date of this standard is set to Q4 2015.

\subsubsection{Bluetooth LE}
BLE is developed to be backwards compatible with Bluetooth,
	but with lower data rate and power consumption [28].
Featuring a data rate of 1Mbit/s with a peak current consumption less than 15mA,
	it is a very efficient protocol for small amounts of data.
Each frame can be transmitted 47bytes in 1Mbit/s = 376Mus;
	thanks to the short transmission time,
	the transceivers consumes less power as the transceiver can be in receive mode or completely off most of the time.
BLE uses its own addressing methods and as the MAC frame size (figure 2.6) is only 39bytes,
	thus IPv6 addressing is not possible.

Starting from Bluetooth version 4.2,
	there is support for IPv6 addressing with the Internet Protocol Support Profile;
	the new version allows the BLE frame to be variable between 2 257 bytes.
The network set-up is controlled by the standard Bluetooth methods,
	whereas IPv6 addressing is handled by 6LoWPAN as specified in IPv6 over Bluetooth Low Energy [29].

\subsubsection{LoaraWAN}
%Low Power Wide Area Networks

\paragraph{SEMTECH}


\paragraph{ALIANCE}



\subsection{Application protocol}

\subsubsection{CoAP}
\begin{itemize}
	\item Constrained Application Protocol
	\item The IETF Constrained RESTful Environments
	\item CoAP is bound to UDP
%	\item Enable devices with low resources to use RESTful interactions
	\item CoAP can be divided into two sub-layers
		\begin{itemize}
			\item messaging sub-layer
			\item request/response sub-layer
			\begin{itemize}
				\item[a)] Confirmable. 
				\item[b)] Non-confirmable. 
				\item[c)] Piggybacked responses. 
				\item[d)] Separate response
			\end{itemize}
		\end{itemize}
	\item CoAP, as in HTTP, uses methods such as:
	\begin{itemize}
		\item GET, PUT, POST and DELETE to 
		\item Achieve, Create, Retrieve, Update and Delete
	\end{itemize}
	\begin{itemize}
		\item Ex: the GET method can be used by a server to inquire the client’s temperature
	\end{itemize}
\end{itemize}

\begin{bytefield}[bitwidth=1em]{32}
	\bitheader{0-31}                                                     \\
	\begin{rightwordgroup}{CoAP Header}                                  \\
	\y{2}{Ver} & \y{2}{T} & \y{4}{TKL} & \y{8}{Code} & \y{16}{Message ID}\\
	\y{32}{Token}                                                        \\
	\y{32}{Options}                                                      \\
	\y{8}{11111111}  \y{24}{Payload}                                     \\
	\end{rightwordgroup}                                                 \\
\end{bytefield}
\begin{itemize}
	\item[\textbf{Ver:}] is the version of CoAP
	\item[\textbf{T:}] is the type of Transaction
	\item[\textbf{TKL:}] Token length
	\item[\textbf{Code:}] represents the request method (1-10) or response code (40-255).
		\begin{itemize}
			\item Ex: the code for GET, POST, PUT, and DELETE is 1, 2, 3, and 4, respectively.
		\end{itemize}
	\item[\textbf{Message ID:}] is a unique identifier for matching the response.
	\item[\textbf{Token:}] Optional response matching token.
\end{itemize}
	
\subsubsection{MQTT}
\begin{itemize}
	\item Message Queue Telemetry Transport
	\item Andy Stanford-Clark of IBM and Arlen Nipper of Arcom
		\begin{itemize}
			\item Standardized in 2013 at OASIS
		\end{itemize}
	\item MQTT uses the publish/subscribe pattern to provide transition flexibility and simplicity of implementation
	\item MQTT is built on top of the TCP protocol
	\item MQTT delivers messages through three levels of QoS
	\item Specifications
		\begin{itemize}
			\item MQTT v3.1 and MQTT-SN (MQTT-S or V1.2)
			\item MQTT v3.1 adds broker support for indexing topic names
		\end{itemize}
	\item The publisher acts as a generator of interesting data.
\end{itemize}

\begin{bytefield}[bitwidth=4em]{8}
	\bitheader{0-7}                                                     \\
	\begin{rightwordgroup}{CoAP Header}                                  \\
	\y{4}{Message Type} & \y{1}{UDP} & \y{2}{QoS Level} & \y{1}{Retain}  \\
	\y{8}{Remaining length}                                                        \\
	\y{8}{Variable length header}                                                      \\
	\y{8}{Variable length message payload}                                     \\
	\end{rightwordgroup}                                                 \\
\end{bytefield}
\begin{itemize}
\item[\textbf{Message type:}] CONNECT (1), CONNACK (2), PUBLISH (3), SUBSCRIBE (8) and so on
\item[\textbf{DUP flag:}] indicates that the massage is duplicated
\item[\textbf{QoS Level:}] identify the three levels of QoS for delivery assurance of Publish messages
\item[\textbf{Retain field:}] retain the last received Publish message and submit it to new subscribers as a first message
\end{itemize}

\subsubsection{XMPP}

\begin{itemize}
	\item Extensible Messaging and Presence Protocol
	\item Developed by the Jabber open source community
	\item An IETF instant messaging standard used for:
	\begin{itemize}
		\item multi-party chatting, voice and telepresence
	\end{itemize}
	\item Connects a client to a server using a XML stanzas
	\item An XML stanza is divided into 3 components:
	\begin{itemize}
		\item message: fills the subject and body fields
		\item presence: notifies customers of status updates
		\item iq (info/query): pairs message senders and receivers
	\end{itemize}
	\item Message stanzas identify:
	\begin{itemize}
		\item the source (from) and destination (to) addresses
		\item types, and IDs of XMPP entities
	\end{itemize}
\end{itemize}

\subsubsection{AMQP}

\begin{itemize}
	\item Advanced Message Queuing Protocol
	\item Communications are handled by two main components
	\begin{itemize}
		\item exchanges: route the messages to appropriate queues.
		\item message queues: Messages can be stored in message queues and then be sent to receivers
	\end{itemize}
	\item It also supports the publish/subscribe communications.
	\item It defines a layer of messaging on top of its transport layer.
	\item AMQP defines two types of messages
	\begin{itemize}
		\item bare massages: supplied by the sender
		\item annotated messages: seen at the receiver
	\end{itemize}
	\item The header in this format conveys the delivery parameters:
	\begin{itemize}
		\item durability, priority, time to live, first acquirer \& delivery count.
	\end{itemize}
	\item AMQP frame format
	\begin{itemize}
		\item[Size] the frame size.
		\item[DOFF] the position of the body inside the frame.
		\item[Type] the format and purpose of the frame.
		\begin{itemize}
			\item Ex: 0x00 show that the frame is an AMQP frame
			\item Ex: 0x01 represents a SASL frame.
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{DDS}

\begin{itemize}
	\item Data Distribution Service
	\item Developed by Object Management Group (OMG)
	\item Supports 23 QoS policies:
	\begin{itemize}
		\item like security, urgency, priority, durability, reliability, etc
	\end{itemize}
	\item Relies on a broker-less architecture
	\begin{itemize}
		\item uses multicasting to bring excellent Quality of Service
		\item real-time constraints
	\end{itemize}
	\item DDS architecture defines two layers:
	\begin{itemize}
		\item[DLRL] Data-Local Reconstruction Layer
		\begin{itemize}
			\item serves as the interface to the DCPS functionalities
		\end{itemize}
		\item[DCPS] Data-Centric Publish/Subscribe
		\begin{itemize}
			\item delivering the information to the subscribers
		\end{itemize}
	\end{itemize}
	\item 5 entities are involved with the data flow in the DCPS layer:
	\begin{itemize}
		\item Publisher:disseminates data
		\item DataWriter: used by app to interact with the publisher
		\item Subscriber: receives published data and delivers them to app
		\item DataReader: employed by Subscriber to access received data
		\item Topic: relate DataWriters to DataReaders
	\end{itemize}
\end{itemize}
\begin{itemize}
	\item No need for manual reconfiguration or extra administration
	\item It is able to run without infrastructure
	\item It is able to continue working if failure happens.
	\item It inquires names by sending an IP multicast message to all the nodes in the local domain
	\begin{itemize}
		\item Clients asks devices that have the given name to reply back
		\item the target machine receives its name and multicasts its IP @
		\item Devices update their cache with the given name and IP @
	\end{itemize}
\end{itemize}

\subsubsection{mDNS}

\begin{itemize}
	\item Requires zero configuration aids to connect machine
	\item It uses mDNS to send DNS packets to specific multicast addresses through UDP
	\item There are two main steps to process Service Discovery:
	\begin{itemize}
		\item finding host names of required services such as printers
		\item pairing IP addresses with their host names using mDNS
	\end{itemize}
	\item Advantages
	\begin{itemize}
		\item IoT needs an architecture without dependency on a configuration mechanism
		\item smart devices can join the platform or leave it without affecting the behavior of the whole system
	\end{itemize}
	\item Drawbacks
	\begin{itemize}
		\item Need for caching DNS entries
	\end{itemize}
\end{itemize}


\subsection{Summary and discussion}


