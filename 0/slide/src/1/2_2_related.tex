\begin{frame}{MDNS}{State of the art}
	\begin{columns}
	
		\begin{column}{0.6\textwidth}
			\begin{itemize}
				\item No need for manual reconfiguration or extra administration
				\item It is able to run without infrastructure
				\item It is able to continue working if failure happens.
				
				\item It inquires names by sending an IP multicast message to all the nodes in the local domain
					\begin{itemize}
						\item Clients asks devices that have the given name to reply back
						\item the target machine receives its name and multicasts its IP @
						\item Devices update their cache with the given name and IP @
					\end{itemize}
				
			\end{itemize}
		\end{column}
		
		\begin{column}{0.4\textwidth}
			\begin{center}
			
				\begin{figure}
					\includegraphics[width=\columnwidth]{mdns.png}
					\caption{\label{fig:mdns} MDNS}
				\end{figure}
				
			\end{center}
			
		\end{column}
	\end{columns}
	
\end{frame}

\begin{frame}{DNS-SD}{State of the art}
	\begin{columns}
		\begin{column}{0.6\textwidth}
		
			\begin{itemize}
				\item Requires zero configuration aids to connect machine
				\item It uses mDNS to send DNS packets to specific multicast addresses through UDP
				\item There are two main steps to process Service Discovery:
					\begin{itemize}
						\item finding host names of required services such as printers
						\item pairing IP addresses with their host names using mDNS
					\end{itemize}
				\item Advantages
					\begin{itemize}
						\item IoT needs an architecture without dependency on a configuration mechanism
						\item smart devices can join the platform or leave it without affecting the behavior of the whole system
					\end{itemize}
				\item Drawbacks
					\begin{itemize}
						\item Need for caching DNS entries
					\end{itemize}
			\end{itemize}
			
		\end{column}
		
		\begin{column}{0.4\textwidth}
			\begin{center}
			
				\begin{figure}
					\includegraphics[width=\columnwidth]{dns-sd.png}
					\caption{\label{fig:dns-sd} DNS-SD}
				\end{figure}
				
			\end{center}
		\end{column}
		
	\end{columns}
	
\end{frame}

\begin{frame}{IoT operating systems}{State of the art}
\changefontsizes{5.3pt}
	\begin{table}[h!]
	\begin{center}
	\begin{tabular}{l|l|c|l|c|c|l|l} % Application protocol
		\bf{OS}      & \bf{Architecture} & \bf{Multi}     & \bf{Scheduling} & \bf{Dynamic}    & \bf{Memory}     & \bf{Network}  & \bf{Virtualization} \\
		\            &                   & \bf{threading} &                 & \bf{Memory}     & \bf{protection} & \bf{Stack} & \bf{and Completion} \\\hline
		\bf{Contiki/Contiki-ng} & Modular        & \ok            & Interrupts      & \ok             & \ko             & uIP          & Serialized          \\
		\            &                   &                & execute w.r.t.  &                 &                 & Rime         & Access              \\\hline
		\bf{MANTIS}  & Modular           & \ko            & Priority        & \ok             & \ko             & At Kernel    & Semaphores.         \\
		\            &                   &                & classes         &                 &                 & COMM layer   &                     \\\hline
		\bf{Nano-RK} & Layered           & \ok            & Monotonic       & \ko             & \ko             & Socket       & Serialized access   \\
		\            &                   &                & harmonized      &                 &                 & abstraction  & semaphores          \\\hline
		\bf{LiteOS}  & Monolithic        & \ok            & Round Robin     & \ok             & \ok             & File         & Synchronization     \\
		\            &                   &                &                 &                 &                 &              & primitives          \\\hline
	\end{tabular}
	\caption{\label{tab:OS} Common operating systems used in IoT environment \cite{al-fuqaha_internet_24}}
	\end{center}
	\end{table}
\end{frame}



