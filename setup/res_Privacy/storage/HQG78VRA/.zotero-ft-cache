Relationship-Based Access Control Policies and Their Policy Languages

Philip W. L. Fong Ida Siahaan
Department of Computer Science University of Calgary
Calgary, Alberta, Canada
{ pwlfong, isrsiaha }@ucalgary.ca

ABSTRACT
The Relationship-Based Access Control (ReBAC) model was recently proposed as a general-purpose access control model. It supports the natural expression of parameterized roles, the composition of policies, and the delegation of trust. Fong proposed a policy language that is based on Modal Logic for expressing and composing ReBAC policies. A natural question is whether such a language is representationally complete, that is, whether the language is capable of expressing all ReBAC policies that one is interested in expressing.
In this work, we argue that the extensive use of what we call Relational Policies is what distinguishes ReBAC from traditional access control models. We show that Fong’s policy language is representationally incomplete in that certain previously studied Relational Policies are not expressible in the language. We introduce two extensions to the policy language of Fong, and prove that the extended policy language is representationally complete with respect to a well-deﬁned subclass of Relational Policies.
Categories and Subject Descriptors
D.4.6 [Security and Protection]: Access Controls
General Terms
Security, Language, Theory
Keywords
Access control policies, modal logic, policy languages, relationship-based access control, social networks
1. INTRODUCTION
The advent of social computing introduces the world to a new paradigm of access control, in which interpersonal relationships are explicitly tracked by the protection system for the purpose of authorization. Gates coined the term Relationship-Based Access Control (ReBAC) to refer
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. SACMAT’11, June 15–17, 2011, Innsbruck, Austria. Copyright 2011 ACM 978-1-4503-0688-1/11/06 ...$10.00.

to this paradigm of access control [17]. In a typical ReBAC system, the protection state consists of a knowledge base of primitive relationships (e.g., friend) between individual users [8], and an access control policy (e.g., friend-of-friend) is expressed in terms of composite relationships induced by the primitive relationships (e.g., friend ◦ friend).
While previously proposed ReBAC systems are designed mostly for social computing applications [23, 9, 8, 34, 35, 16], a formal ReBAC model was proposed recently as a generalpurpose access control model [15]. The model features polyrelational social networks with asymmetric relations, as well as a context-dependent authorization procedure that limits the scope of relationships to their applicable contexts. Fong articulates three beneﬁts of the ReBAC paradigm in general, and of his ReBAC model in particular. First, formulating policies in terms of binary relationships between users supports the natural expression of authorization decisions that are based on the relative attributes of the accessor as perceived by the resource owner (e.g., trust, professional association, etc). Traditional access control systems base their authorization decisions on some unary predicates of the users (e.g., identities, roles, etc) that is deﬁned by a central authority. The limitations of such an approach becomes evident as notions such as parameterized roles [29] (or role templates [19]) creep into RBAC systems: e.g., the parameterized role manager(john) signiﬁes the role assumed by the manager of John. In many emerging application domains, such as social computing and Electronic Health Records Systems, in which the protection of user-contributed contents is prominent, accessibility depends not on the intrinsic attributes of the accessor, but on the relationship between the accessor and the owner (e.g., the professional relationship) [5, 30]. ReBAC provides natural support for such situations. Second, relationship-based access control policies support a richer form of policy composition. With policies that are based on unary predicates, the only interesting form of policy composition would be boolean combinations (i.e., ∧, ∨, ¬), which can be captured readily by, say, a role hierarchy. Binary relations, however, supports a much richer form of composition, including relational composition (friend◦friend) and transitive closure (friend+). Third, a composite binary relation supports delegation of trust in a natural way: e.g., by adopting the policy friend-of-friend, I am delegating to my friends to decide who can access.
Fong also proposed a policy language for expressing ReBAC policies [15]. The language is based on a basic modal logic, and it has been shown to be capable of expressing complex, composite relationships between an owner and an ac-

51

cessor, such as those found in an Electronic Health Records (EHR) system [4]. One natural question to ask is whether the policy language of Fong is representationally complete, that is, whether it is capable of expressing all the ReBAC policies we would like to express. In this work, we give a negative answer to the question, we extend the policy language to cover its shortcomings, and we formally characterize the expressive power of the extended policy language. In this last respect, this research has close aﬃnity to enforceability research, as exempliﬁed in [33, 26, 13, 21, 36, 27, 28], which formally characterizes the structural relationships between naturally occurring policy families, and the family of policies enforceable by a given enforcement mechanism.
Our contributions are threefold:
1. A distinguished feature of ReBAC is its extensive use of what has come to be known as relational policies [1]. We demonstrate, in Section 2, that a number of relational policies previously studied in the context of Facebook-style Social Network Systems [16] cannot be expressed in the policy language of Fong.
2. We introduce, in Section 3, two new features into the ReBAC policy language, and demonstrate that the resulting language is capable of expressing the abovementioned relational policies.
3. In Section 4, we formally characterize the expressiveness of the extended policy language by proving both an “upper bound” and a “lower bound” for the family of ReBAC policies expressible in the language. The upper-bound result shows that, every policy expressible in the extended policy language belongs to the family of owner-checkable policies. The lower-bound result identiﬁes a natural subclass of relational policies, namely, ﬁnitary relational policies, that are provably expressible in the extended language: the extended language is representationally complete with respect to ﬁnitary relational policies.
2. INADEQUACY OF B
This section gives an overview of the background on which this work is based, and articulates the representational incompleteness of the basic policy language of Fong [15].
2.1 Notation
Given a binary relation R ⊆ X × Y and individuals x ∈ X and y ∈ Y , we write R(x, y) iﬀ (x, y) ∈ R. We write 2X for the powerset of X (i.e., the set of all subsets of X), [X]k for the set of all subsets of X that have a cardinality k, and [X]<ω for the set of all ﬁnite subsets of X. We write f : X Y whenever f is a function with a subset of X as its domain and Y as its co-domain. We write ∅ for a function with an empty domain. Consider a function f : X Y and individuals x0 ∈ X and y0 ∈ Y . We write f [x0 → y0] to denote the function f : X Y deﬁned as follows: f (x) = y0 if x = x0, but f (x) = f (x) if x = x0.
2.2 Social Networks and Relation Identiﬁers
We assume that an SNS deﬁnes a ﬁnite set I of relation identiﬁers. Each identiﬁer denotes a type of relationships that is tracked by the system (e.g., parent-child, patientphysician, etc). A typical member of I is denoted by i.

A social network is essentially a directed graph with multiple kinds of edges. While individuals are represented by vertices, each kind of directed edges represents a distinct type of relationship between users. Formally, a social network G is a relational structure [6] of the form V, {Ri }i∈I , where:
• V is a ﬁnite set of vertices, each representing an individual in the social network.
• {Ri }i∈I is a family of binary relations. The binary relation Ri ⊆ V × V speciﬁes the pairs of individuals participating in relationship type i.
We write V (G) and Ri (G) respectively for the V and Ri components of the social network G.
Standard graph-theoretic concepts apply to social networks in an expected manner. We outline a few to ﬁx thoughts. We write G ⊆ G whenever V (G) ⊆ V (G ) and Ri (G) ⊆ Ri (G ) for every i ∈ I. G is said to be a subgraph of G . Suppose U ⊆ V (G). We write G[U ] to denote the social network U, {Ri }i∈I , where Ri = Ri (G) ∩ (U × U ). G[U ] is said to be the subgraph of G induced by U . Two social networks G, G are isomorphic iﬀ there is a bijective function π : V (G) → V (G ) such that (u, v) ∈ Ri (G) whenever (π(u), π(v)) ∈ Ri (G ). In this case, we write G ∼= G , and call π an isomorphism between G and G .
Given a social network G, we deﬁne the acquaintance graph acq(G) to be the simple graph V (G), E , where E = {{u, v} ∈ [V (G)]2 | ∃i ∈ I .(u, v) ∈ Ri (G)}. That is, an acquaintance graph shares the same vertex set as the social network, and there is an undirected edge between two distinct vertices in the acquaintance graph iﬀ there is a typed, directed edge between the same pair of vertices in the social network. Note that, although loops may occur in the social network, the acquaintance graph is a simple graph, and thus it contains no loops. The purpose for deﬁning the acquaintance graph is to reuse connectivity-related concepts from standard graph theory. Speciﬁcally, notions such as distance, connected-ness, and components can be applied to a social network. For example, two vertices in a social network G are said to be connected iﬀ there is an undirected path1 between them in acq(G); the distance between two connected vertices in G is the length of the shortest path between them in acq(G); an (extended) neighbourhood of a vertex u in G is the set NG∗ (u) of vertices connected to u in acq(G); the component of G to which u belongs is the social network CG(u), which is deﬁned to be G[NG∗ (u)]. Lastly, we write CG(u; v) to denote the social network G[NG∗ (u) ∪ {v}], which is called an augmented component. The idea is to form the component of G to which u belongs, but with the augmentation of vertex v. If u and v are connected, then CG(u) = CG(u; v). Otherwise, CG(u; v) contains CG(u) plus an additional, isolated vertex v.
Suppose U is a countable set of user identiﬁers. We denote by G(U, I) the set of all ﬁnite social networks deﬁned for user set U and relation identiﬁer set I. That is, G(U, I) = { V, {Ri }i∈I | V ∈ [U ]<ω, Ri ⊆ V × V }. G(U , I) contains all the social networks with a vertex set that is a ﬁnite subset of U. Since I is ﬁnite, such a social network has only ﬁnitely many edges. Note that, although every member of G(U, I) is ﬁnite in size, the size of such a member is not bounded.
1We consider a vertex to be connected to itself by a lengthzero path. Consequently, u is always a member of NG∗ (u).

52

2.3 ReBAC Policies
In [15] a formal model of ReBAC is introduced. The state of a ReBAC system is a collection of social networks, as deﬁned above. State transition involves the mutation of the social networks (e.g., addition and deletion of relationship edges). An access attempt involves an accessor requesting access to a resource owned by an owner 2. When an access is attempted at a given state, the policy that controls the accessibility of the requested resource will be evaluated against a certain social network induced by the current state. The policy either allows or denies the request. In the following, we formally specify what a ReBAC policy is.
A ReBAC policy deﬁnes a desired binary relation between resource owners and resource accessors in the context of a given social network. Suppose we are given a ﬁxed set U of users and a ﬁxed set I of relation identiﬁers. A ReBAC policy is a family of binary relations over U, indexed by social networks from G(U, I). More speciﬁcally, a policy is a function P : G(U , I) → 2U×U , such that P (G) ⊆ V (G) × V (G) for every social network G ∈ G(U, I). Intuitively, a policy P speciﬁes, for each social network G, a binary relation P (G) that relates each resource owner to those accessors that the policy grants access. That is, (u, v) ∈ P (G) iﬀ owner u grants access to accessor v in the context of social network G. Note that P (G) contains only ﬁnitely many pairs because G has only ﬁnitely many vertices. Using the notation deﬁned in Section 2.1, we write P (G)(u, v) whenever (u, v) ∈ P (G).
In a typical ReBAC system, only a certain vocabulary of ReBAC policies is supported. For example, in Facebook, the policy vocabulary includes ReBAC policies such as me, friend, friend-of-friend, everyone, etc. A resource owner will adopt a supported policy from the policy vocabulary to protect a resource. The following are examples of ReBAC policies. They were previously proposed in [16] in the study of Facebook-style Social Network Systems (FSNSs). They have been adapted here as examples of ReBAC policies.
Example 1 (Distance). Suppose the set of relational identiﬁers is I = {friend}. Suppose further that the relation identiﬁed by friend is symmetric (but not necessarily irreﬂexive). We call such social networks pseudo-Facebook social networks (the friend relation of a genuine Facebook-style social network is irreﬂexive). Deﬁne the policy distk such that distk(G)(u, v) iﬀ u and v is at a distance k or less from one another. This policy is a generalization of the friend-offriend policy in Facebook. Speciﬁcally, the distance between two vertices is taken as a measure of the strength of trust between two individuals.
Example 2 (Common Friends). Consider again pseudo-Facebook social networks. Deﬁne the policy cfk such that cfk(G)(u, v) iﬀ (a) u = v, or (b) v is a neighbour of u, or (c) there are k (or more) common neighbours between u and v. Intuitively, access is granted to a stranger if k friends of the owner witness to the trustworthiness of this stranger. This policy is another generalization of the friendof-friend policy in Facebook. Speciﬁcally, the number of common neighbours is taken as a measure of the strength of trust between two strangers. Having the trust level exceeding the threshold k results in access granting.
2In [15], an access attempt also involves an access context. We ignore the latter as it is irrelevant to this work.

Example 3 (Clique). Consider yet again pseudoFacebook social networks. Deﬁne the policy cliquek such that cliquek(G)(u, v) iﬀ (a) u = v, or (b) u and v belong to a clique3 of size k (or more) in acq(G). Intuitively, access is granted if the accessor and the owner belong to a close-knit community of size k (or more). This policy is a generalization of the friend policy in Facebook. Speciﬁcally, the size of the largest common clique to which two neighbouring individuals belong is taken as a measure of the strength of trust between them. Having a trust level exceeding the threshold k results in access granting. Other notions of close-knit communities [10], such as clans, plexes and cores, can also be modelled in a similar way.
2.4 Relational Policies
Anwar et al. identify a family of policies, called relational policies, the use of which distinguishes ReBAC from traditional access control paradigms [1]. Intuitively, a relational policy is special in two ways. First, a relational policy does not base authorization decisions on the identities of the owner or the accessor. Instead, only the topological structure the social network is analyzed for authorization. Second, a relational policy speciﬁes how the owner and the accessor shall be related in the social network (e.g., the owner and the accessor are at a distance no more than k), rather than individual properties of the owner or the accessor (e.g., the accessor has a vertex degree no less than k). These two characteristics are captured in the following deﬁnitions, which we generalized from those in [1].
Definition 4. A policy P is topology-based iﬀ, for every pair of isomorphic social networks G, G ∈ G(U, I) with isomorphism π : V (G) → V (G ), we have (u, v) ∈ P (G) whenever (π(u), π(v)) ∈ P (G ).
In short, a topology-based policy depends only on the topological information of the social network, but not on the identities of the users.
The next deﬁnition characterizes policies that specify how the owner and the accessor are related to one another.
Definition 5. A policy P is local iﬀ, given G ⊆ G and u, v ∈ V (G) for which (u, v) ∈ P (G)\P (G ) ∪ P (G )\P (G), there exists i ∈ I such that Ri (G )\Ri (G) contains a pair (u , v ) for which each of u and v is connected to each of u and v in G .
The intuition of the deﬁnition is the following. Suppose P is a local policy. Suppose further that the authorization decision of P is altered for a pair of individuals (u, v) after one adds vertices and edges into the social network G to obtain social network G . Then G must have received a new edge (u , v ) of some relationship type i, such that each of u , v is connected to each of u, v. In short, adding vertices or edges outside of the shared component of the owner and the accessor never alters the authorization decision of a local policy. Put more succinctly, the ends of every edge that has an inﬂuence on authorization decisions must connect both the owner and the accessor. That is, such an edge must contribute to the “connectedness” between the owner and the accessor. In this way, we capture the intuitive requirement that the policy must specify how the owner and the accessor
3A clique is a complete subgraph. Here we mean that u and v are part of a complete subgraph of the social network.

53

are related to one another, rather than specifying individual graph properties of the owner or the accessor.

Definition 6. A policy is relational iﬀ it is both topology based and local.

Note that the three example policies (i.e., distance, common friends and cliques) are all relational policies.

2.5 The ReBAC Policy Language B
Fong proposed a policy language for expressing ReBAC policies [15]. We call his language B to diﬀerentiate it from the extended language E to be presented in the sequel. The language B is a basic modal logic [6]. Each formula in B expresses a ReBAC policy: i.e., a desirable relationship between two individuals in a social network. The syntax of a B formula, which is based on a set I of relation identiﬁers, is given below4:

φ, ψ ::= | a | ¬φ | φ ∧ ψ | i φ | −i φ

where i ∈ I is a relation identiﬁer. A policy (i.e., a formula) φ is interpreted in the context of
a social network G ∈ G(V, I) and individuals u, v ∈ V (G). Speciﬁcally, the semantics of B is given in a satisﬁability relation G, u, v |=B φ, which asserts that, in social network G, owner u and accessor v possess the relationship prescribed by policy φ.

• G, u, v |=B .

• G, u, v |=B a iﬀ u = v.

• G, u, v |=B ¬φ iﬀ it is not the case that G, u, v |=B φ.

• G, u, v |=B φ∧ψ iﬀ both G, u, v |=B φ and G, u, v |=B ψ.

• G, u, v |=B i φ iﬀ there exists u ∈ V (G) such that (u, u ) ∈ Ri (G) and G, u , v |=B φ.

• G, u, v |=B −i φ iﬀ there exists u ∈ V (G) such that (u , u) ∈ Ri (G) and G, u , v |=B φ.

Intuitively, is a relationship satisﬁable by any pair of individuals; a asserts that the accessor is the owner; i φ asserts that the owner has an i-neighbour that is related to the accessor in the manner speciﬁed by φ; −i φ asserts that the owner is the i-neighbour of some individual that is related to the accessor in the manner speciﬁed by φ. The diﬀerence between i and −i is that the former traverses along the direction of an edge, while the latter traverses against the direction of an edge. Standard derived forms are deﬁned:

⊥=¬ φ ∨ ψ = ¬(¬φ ∧ ¬ψ)

[i] φ = ¬ i ¬φ [−i] φ = ¬ −i ¬φ

Intuitively, [i] φ asserts that every i-neighbour of the owner is related to the accessor in the manner speciﬁed by φ.
A ReBAC policy P is deﬁnable in B iﬀ there is a B formula φ such that P (G)(u, v) whenever G, u, v |=B φ. It has been demonstrated that many complex relational policies are deﬁnable in B. Speciﬁcally, Fong [15] was able to use B
4The modal operator −i is not found in [15]. Instead, it is assumed in [15] that social networks are “inverse-closed.” The two achieve the same eﬀect: the authorization procedure can freely traverse either along or against the direction of an edge.

to capture all the trust delegation policies identiﬁed in the Electronic Health Records case study developed by Becker and Sewell [4]. We illustrate the usage of B with a few examples. Consider social networks with relation identiﬁers I = {parent, child, spouse, sibling}, which signify respectively the child-parent relation, its inverse, the symmetric spousespouse relation, and the reﬂexive symmetric sibling-sibling relation. The following policies are deﬁnable in B:
“Grant access to grand parents.” The B formula that expresses this policy is “ parent parent a”.
“Grant access to a sibling who is not married.” The B formula that expresses this policy is:
sibling (a ∧ [spouse] ⊥)
“Grant access if accessor is the only child of the owner.” A formula to express the policy is:
child a ∧ [child] a
2.6 Limitations of B
B is not without limitations. It turns out that some relational policies are not deﬁnable in B.
Example 7. Assume the setting of Example 2. The policy cfk, for every k > 2, is not deﬁnable in B. The reason is that the models for these policies are bisimilar to cf1, and thus indistinguishable by a formula of B [6]. For instance, consider cf2. A naive attempt to express cf2 in B yields the following formula:
a ∨ friend a ∨ ( friend friend a ∧ friend friend a)
The intention is that the disjuncts “a” and “ friend a” respectively express requirements (a) and (b) in Example 2, while the third disjunct expresses requirement (c). Supposedly, each of the two conjuncts “ friend friend a” identiﬁes a common friend of the owner and the accessor. Unfortunately, this formula does not express cf2. Consider the scenario in which the owner and the accessor share exactly one common neighbour. Since conjunction is idempotent, the formula above is satisﬁed even though cf2 should fail.
In the formula above, the original intention is that the two conjuncts specify two disjoint sets of intermediaries (i.e., two distinct common friends). Unfortunately, boolean conjunction fails to capture this requirement. This illustrates the need for an ReBAC policy language to provide a nonidempotent version of conjunction for specifying disjoint sets of intermediaries.
Example 8. The policy cliquek is not deﬁnable in B, for every k > 2. For instance, consider clique3. A naive attempt to express the policy is the following formula:
a ∨ (¬a ∧ friend a ∧ friend (¬a ∧ friend a))
The intention is that the disjunct “a” expresses requirement (a) in Example 3, while the second disjunct expresses requirement (b). In the second disjunct, we assert that the owner is not the accessor (¬a), the accessor is a friend of the owner ( friend a), and the accessor is a friend of a friend of the owner ( friend (¬a ∧ friend a)). Yet, the following two social networks are not distinguishable by B formulas.
•c

uÑ

Gv

u

Gv1

54

Speciﬁcally, the sub-formula “ friend (¬a ∧ friend a)” fails to ensure that the owner (u) and the intermediary (•) are two distinct vertices.
The above example illustrates an important shortcoming of the policy language B, namely, its lacking a vertex identiﬁcation mechanism: i.e., the ability to name vertices and subsequently test if they are revisited.
As pointed out in [16], relational policies such as cfk and cliquek are rich in social signiﬁcance, and thus the lacking of disjoint intermediaries and vertex identiﬁcation in B needs to be remedied.
3. THE REBAC POLICY LANGUAGE E
In the previous section, we identiﬁed two limitations of the policy language B, namely, disjoint intermediaries and vertex identiﬁcation. We now look at how the two features can be incorporated into a ReBAC policy language. The result is an extended ReBAC policy language we call E.
Syntax.
As before, E is deﬁned in the context of a countable set U of vertices and a countable set I of relation identiﬁers. We assume that there is a countably inﬁnite set P of propositional symbols. We write p and q for typical members of P. We also assume that P contains a distinguished member a.
The syntax of E is given below:
φ, ψ ::= | p | ¬φ | φ ∧ ψ | i φ | −i φ | @p.φ | φ ⊗ ψ
where p ∈ P is a propositional symbol, and i ∈ I is a relation identiﬁer. Intuitively, @p.φ introduces a propositional symbol for identifying the owner. Speciﬁcally, the proposition symbol p can be used inside φ to test if a vertex is the owner. The formula φ ⊗ ψ holds whenever the relationships prescribed by φ and ψ both hold between the accessor and the owner, but the set of intermediary vertices used for establishing these two relationships are disjoint. A more precise deﬁnition of the semantics of these new constructs is given below.
The notion of free and bound occurrences of propositional symbols can be deﬁned in a standard way. For example, in the formula (p ∧ @q. i q), the propositional symbol p occurs free but q occurs bound. A formula is a-closed if no propositional symbol other than a occurs free in the formula. Otherwise the formula is a-open.
Semantics.
Given a social network G, a function Σ : P V (G) is called a binding environment5. A binding environment interprets a propositional symbol as a vertex.
The semantics of E is deﬁned via the satisfaction relation G, u, v |=E φ, which is speciﬁed in terms of an auxiliary relation G, Σ, u φ, where Σ is a binding environment.
• G, Σ, u .
5Note that our binding environment plays the role of a valuation or labelling function in the standard literature of modal logic [6], in which a valuation is a function with signature P → 2V (G), and a labelling function is a function with signature V (G) → 2P . In our logic, a propositional symbol is interpreted as a single vertex. We therefore adapt the deﬁnition to ease presentation.

• G, Σ, u p iﬀ Σ(p) = u.
• G, Σ, u ¬φ iﬀ it is not the case that G, Σ, u φ.
• G, Σ, u φ ∧ ψ iﬀ both G, Σ, u φ and G, Σ, u ψ.
• G, Σ, u i φ iﬀ there exists u ∈ V such that (u, u ) ∈ Ri and G, Σ, u φ.
• G, Σ, u i φ iﬀ there exists u ∈ V such that (u , u) ∈ Ri and G, Σ, u φ.
• G, Σ, u @p.φ iﬀ p = a and G, Σ[p → u], u φ.
• G, Σ, u φ ⊗ ψ iﬀ the following holds:
Let v be Σ(a). There exists two subsets V1 and V2 of V (G), such that V (G) = V1 ∪ V2, V1 ∩ V2 = {u, v}, and both G[V1], Σ, u φ and G[V2], Σ, u φ hold.
Lastly, G, u, v |=E φ iﬀ G, ∅[a → v], u φ.
Derived Forms.
We deﬁne the derived forms ⊥, φ ∨ ψ, [i] φ and [−i] φ as before. In addition, we introduce the following derived form:
φ ⊕ ψ = ¬(¬φ ⊗ ¬ψ)
The connective ⊕ is the dual of ⊗. Speciﬁcally, G, Σ, u φ ⊕ ψ iﬀ the following holds:
Let v be Σ(a). For every two subsets V1 and V2 of V (G) such that V (G) = V1 ∪V2, V1 ∩V2 = {u, v}, either G[V1], Σ, u φ or G[V2], Σ, u φ holds.
In other words, G, Σ, u φ ⊕ ψ whenever, for every subset V of V (G) such that {u, Σ(a)} ⊆ V , either G[V ], Σ, u φ or G[V ], Σ, u φ holds.
Deﬁnability.
A policy P is deﬁnable in E iﬀ there is an a-closed formula φ in E such that P (G)(u, v) whenever G, u, v |=E φ.
Examples.
The following examples illustrate how the new features of E address the needs for disjoint intermediaries and vertex identiﬁcation.
Example 9. The policy cf2 is deﬁnable in E, via the following formula:
a ∨ friend a ∨ (( friend friend a) ⊗ ( friend friend a))
Example 10. The policy clique3 is deﬁnable in E, via the following formula:
a ∨ (¬a ∧ friend a ∧ @p. friend (¬p ∧ ¬a ∧ friend a))
4. EXPRESSIVENESS OF E
It has been pointed out in Section 2.4 that ReBAC is distinguished by its extensive use of access control policies are relational : i.e., authorization decisions consume only topological information of the social network (topology-based), and express how the owner and the accessor are related in the social network (local). In this section, we will examine the expressiveness of E by identifying what family of relational policies are deﬁnable in E. We will ﬁrst establish, in

55

Section 4.1, an “upper bound” of the policies deﬁnable in E: i.e., identifying a natural family of ReBAC policies to which every E-deﬁnable policy belongs. We will then establish, in Section 4.2, a “lower bound” of the expressiveness of E. That is, we will identify a natural subclass of relational policies that are deﬁnable in E. In other words, we establish the representational completeness of E with respect to that subclass of relational policies. We conclude the section with a structural analysis of the hierarchy of policy families identiﬁed along the way (Section 4.3).
4.1 Owner-checkable policies
We begin our discussion with the family of topology-based policies that can be enforced by an agent that traverses a neighbourhood of the owner.
Definition 11. A topology-based policy P is ownercheckable (OC) iﬀ P (G)(u, v) ⇔ P (CG(u; v))(u, v). A topology-based policy P is accessor-checkable (AC) iﬀ P (G)(u, v) ⇔ P (CG(v; u))(u, v).
Intuitively, the authorization decision of an OC policy can be determined by examining only the component of social network in which the owner is located, plus the additional knowledge of whether the accessor is in that component (CG(u; v)). That is, even if there may be vertices and edges outside of the owner’s component, they never inﬂuence the authorization decision. The intuition of an AC policy is analogous.
An OC policy is special in two ways. Firstly, an OC policy presents a tractability advantage. In particular, an OC policy can be evaluated by a “crawler” that traverses only the owner’s component (i.e., neighbourhood), starting at the owner vertex. Venturing outside of the owner’s component is never necessary. An AC policy shares the same tractability advantage if the traversal begins at the accessor’s vertex. Secondly, an OC policy provides a security advantage. Although an AC policy provides the same tractability advantage as an OC policy, only an OC policy provides this form of security advantage. The checking of an AC policy can be conducted by a “crawler” that traverses the accessor’s component, starting at the accessor. Yet, an AC policy may lead to a denial-of-service attack by the accessor. Speciﬁcally, the accessor may carefully craft its neighbourhood in such a way that would lead the “crawler” (i.e., the authorization procedure) to explore a graph neighbourhood that is expensive to traverse (with respect to the policy in question). Even if access is not granted, an accessor may repeatedly request access, leading the authorization procedure to waste precious computational resources. An OC policy prevents this form of manipulation, in the sense that the accessor cannot dictate the computational cost of authorization.
Relational policies are related to OC and AC policies.
Proposition 12. A relational policy is both OC and AC.
(A proof of this proposition can be found in Appendix A.) The following theorem represents an “upper bound” to the
expressiveness of E.
Theorem 13. A policy deﬁnable in E is OC.
(A proof of this theorem can be found in Appendix A.) A corollary of Theorem 13 is that, if a policy can be ex-
pressed as an E formula, then there is no need for an additional syntactic analysis to ensure that the policy is OC.

This contrasts with the use of alternative policy languages (e.g., Datalog), whereby an additional analysis is needed to ensure the policy is indeed OC.
4.2 Finitary Relational Policies
We now turn to the “lower bound” of E’s expressiveness. The authorization decisions of a ReBAC policy can be determined in two ways. One is to grant access when certain relationships are present in the social network, the other is to grant access when certain relationships are absent. The evaluation of a policy of the second kind requires complete knowledge of the entire social network, while the evaluation of a policy of the ﬁrst kind requires only a fragment of the social network to provide an existential proof of compliance. The following deﬁnition formalizes the idea.
Definition 14. A policy P is monotonic iﬀ G ⊆ G implies P (G) ⊆ P (G ).
That is, adding relationships into a social network never reduces accessibility, and removing relationships never expands accessibility. Such a policy makes authorization decisions by verifying the presence of relationships rather than the absence of relationships. The notion of monotonicity was originally proposed in [16] for Facebook-style Social Network Systems. Here we generalize the notion for ReBAC policies.
Adopting policies that are exclusively monotonic enables a decentralized implementation of ReBAC in the style of trust management systems [7, 37, 25, 24]. Speciﬁcally, an accessor who seeks authorization may present to the reference monitor a fragment of the social network (e.g., a collection of certiﬁcates of relationships) as a proof of compliance. We are therefore interested in policies that are both monotonic and topology based.
Definition 15. A policy P is positive iﬀ it is both topology based and monotonic.
We review here a characterization of positive policies. Our characterization is phrased in terms of birooted graphs.
Definition 16. A birooted graph G(u,v) is a triple G, u, v such that G is a social network and u, v ∈ V (G). The vertices u and v are the roots of G(u,v), and they need not be distinct. Speciﬁcally u is the owner root, and v is the accessor root. We write B(S, I) = {G(u,v) | G ∈ G(S, I), u, v ∈ V (G)} to denote the set of all birooted graphs based on vertex set S. G (u,v) is a (birooted) subgraph of G(u,v), written as G (u,v) ⊆ G(u,v), iﬀ G ⊆ G. (Note the matching roots.) We say that G(u,v) and G (u ,v ) are isomorphic iﬀ there exists an isomorphism π : V (G) → V (G ) between social networks G and G , such that π(u) = u and π(v) = v . In this case we write G(u,v) ∼= G (u ,v ). We also write G (u ,v ) G(u,v) whenever there is a birooted graph G (u,v) such that G (u ,v ) ∼= G (u,v) and G (u,v) ⊆ G(u,v).
We are now ready to state the characterization theorem for positive policies.
Definition 17. The policy positively induced by a set B of birooted graphs is the policy PB+ for which
PB+(G)(u, v) iﬀ ∃G (u ,v ) ∈ B . G (u ,v ) G(u,v)
Intuitively, the birooted graph set B speciﬁes topological “patterns” that must exist between an owner and an accessor

56

in the social network in order for access to be granted by the policy. It was proven in [1] that every positive policy can be characterized by a set of birooted graph patterns. The result was originally established for Facebook-style Social Network Systems. Here, we adapt the result to the more general context of ReBAC.
Theorem 18. Every positive policy is positively induced by a set of birooted graphs. The minimal set of birooted graphs to positively induce a given policy P is deﬁned to be the set B for which there exists no proper subset of B that also positively induces P . This minimal set does not contain a pair of distinct birooted graphs G(u,v) and G (u ,v ) such that G(u,v) G (u ,v ). Such a minimal set always exists, and is unique up to birooted graph isomorphism.
Intuitively, every positive policy can be uniquely characterized by a smallest set of birooted graph patterns.
We are particularly interested in a special kind of positive policies.
Definition 19. A positive policy P is ﬁnitary iﬀ the minimal set of birooted graphs to positively induce P is a ﬁnite set.
Finitary policies can be characterized by a ﬁnite number of birooted graphs. While positive policies can be evaluated by checking for the presence of relationships, the ﬁnitary requirement ensures that only a bounded number of such relationships need to be enumerated. This requirement is computationally signiﬁcant in two ways. Firstly, this translates to a bound in the search eﬀort for a centralized implementation of the authorization procedure, for the search tree now has bounded depth. Secondly, in a distributed implementation of ReBAC, this constraint implies that a proof of compliance consists of a bounded number of certiﬁcates.
We are now ready to state the main theorem of this work.
Theorem 20. Every ﬁnitary OC policy is deﬁnable in E.
The theorem provides a “lower bound” of what can be expressed in E. The proof of this theorem can be found in Appendix A.
Recall that our core interest is in expressing relational policies, rather than OC policies. The following corollary, which follows directly from proposition 12, identiﬁes a subclass of relational policies deﬁnable in E.
Corollary 21. Every ﬁnitary relational policy is deﬁnable in E.
Note that all the three example policies (i.e., distance, common friends, and clique) are ﬁnitary relational policies.
We can further strengthen the above result. Suppose P1 and P2 are deﬁnable in E via the formulas φ1 and φ2. Consider the policy P deﬁned such that P (G) = P1(G) ∩ P2(G). That is, P grants access whenever both P1 and P2 grant access. It is easy to see that P is also deﬁnable in E, via the formula φ1 ∧ φ2. The same can be said about other boolean combinations (disjunction and negation).
Corollary 22. The family of policies deﬁnable in E is closed under boolean combinations. Consequently, boolean combinations of ﬁnitary relational policies are deﬁnable in E. Note that such boolean combinations of ﬁnitary relational policies are still relational policies, although they are not necessarily ﬁnitary.
This corollary gives us an easy extension of the deﬁnability result in Corollary 21.

Figure 1: The hierarchy of policy families identiﬁed in this work: TB: topology-based policies; OC: owner-checkable policies; Rel: relational policies; Pos: positive policies; Fin: ﬁnitary policies; FR: ﬁnitary relational policies.
4.3 Discussion
Figure 1 depicts the hierarchy of policy families identiﬁed in this section. Note that every inclusion in Figure 1 is proper. To demonstrate this, the following list states a member policy for each set diﬀerence.
TB\(Pos ∪ OC): The social network contains no more than k vertices (including the owner and the accessor).
Pos\Fin: The owner and the accessor are connected.
Fin\FR: The accessor has at least k neighbours.
OC\Rel: The owner has no more than k neighbours.
Rel\FR: The owner and the accessor are not connected.
5. RELATED WORK
The term Relationship-Based Access Control (ReBAC) was ﬁrst coined by Gates [17] when she articulated the need for an access control paradigm that is based on interpersonal relationships. A number of ReBAC models and/or systems have been proposed for social computing applications [23, 9, 8, 34, 35, 16]. The targets of study include the distributed evaluation of trust [9], the employment of semantic web technology to encode social networks and ReBAC policies [8], the automatic generation of ReBAC policies [34], multiple ownership of resources [35], the generalization of Facebookstyle Social Network Systems [16], and the characterization of relational policies [1]. Fong advocates the employment of ReBAC in application domains outside of social computing [15], and demonstrates the utility and feasibility of doing so by the speciﬁcation of a general-purpose ReBAC model and a ReBAC policy language. He points out that the various constructs in his ReBAC model arise naturally out of the generalization of foundational concepts such as roles, role hierarchy, sessions and constraints in Role-Based Access Control (RBAC) [31, 12]. His work also raises the question of representational completeness, which is the focus of this work. The core contribution of this work is (a) demonstrating that Fong’s policy language fails to encode a number of relational policies previously studied in [16], (b) incorporating the support of disjoint intermediaries and vertex identiﬁcation into a ReBAC policy language that is based on modal logic, and (c) providing both an upper bound and

57

a lower bound to the family of policies expressible in the extended policy language.
The question of representational completeness is related to enforceability research [33, 26, 13, 21, 36, 27, 28]. The goal of enforceability research is to establish the structural relationships between naturally occurring policy families (e.g., safety policies), and the family of policies enforceable by a speciﬁc kind of enforcement mechanisms (e.g., program monitors that have access only to the execution history). Rather than relating policy families to enforcement mechanisms, this work establishes upper bound and lower bound for the family of policies deﬁnable in a policy language.
Policies such as cfk (for k > 2) are not deﬁnable in B. The reason is that the models for these policies are bisimilar to cf1, and thus indistinguishable by a formula of B [6]. Therefore, in E a new connective ⊗ is introduced to require disjoint partitioning of the social network during a satisﬁability check (except for the accessor and the owner). This approach is similar to manifold roles by Li et al. in RT T [25]. The credential using ⊗ in RT T is a union of the sets where the intersection of such sets is empty. The concept of threshold structure by Li et al. in Delegation logic [24] is also similar to ⊗. In a threshold structure, k out of N principals are required, where each of the k is unique.
6. FUTURE WORK
Some extensions to the ReBAC model have been suggested in [15]. We discuss in the following future directions that are speciﬁc to ReBAC policy languages.
A natural future work is to improve the precision of the characterization of policies deﬁnable in E. Speciﬁcally, there is a “gap” between the “upper bound” and “lower bound” presented in Section 4. As demonstrated in Section 4.3, the inclusion of FR in OC is proper. It is desirable if one can close the gap, and provide a precise identiﬁcation of the family of policies deﬁnable in E.
One of the motivations for designing a policy language for ReBAC policies is to facilitate policy analysis. It has been shown [14] that proper static analysis can be applied to the conﬁguration of Facebook-style Social Network Systems to ensure the absence of Sybil attacks. It is interesting to explore if this or other policy analyses can be translated into an equivalent syntactic analysis for policies written in a ReBAC policy language.
Both this work and [15] assume the ReBAC system tracks relationships explicitly, and the relations are in turn identiﬁed by a ﬁxed vocabulary of relation identiﬁers. This assumption has made the design of rich policy languages possible. In some applications, however, the presence of a relationship is induced by complex external factors. For example, consider a network consisting of users and devices such as mobile phones, in which the presence of a relationship is the result of the states of the mobile phones (e.g., battery level) and their relative proximity. Rational modelling of such external dependence would allow us to reuse ReBAC and our policy languages even in these application domains.
Another future direction is to combine the strengths of both RBAC and ReBAC, thereby allowing the access control system to reason about both the relationships between individuals, and the hierarchical organization of user roles. One possibility is to employ Description Logic (DL) technology [2] as the basis of both the policy language and the authorization engine. Highly related to modal logics [32], DL is a

mature technology, with language families of various levels of tractability, and the support of eﬃcient reasoners (e.g., RACER [20] and FaCT [22]). A previous work on applying DL to access control is that of RelBAC [18, 38], in which DL is employed to construct an access control model akin to Domain-Type Enforcement (DTE) [3]. Further work is needed to integrate ReBAC and RBAC in one model.
7. CONCLUSION
This work examined the relative expressiveness of two ReBAC policy languages. We began by demonstrating that there are known relational policies, such as cfk and cliquek, that cannot be expressed in the ReBAC policy language B. We pointed out that the limitations were due to the lack of support for disjoint intermediaries and vertex identiﬁcation. The two features were then incorporated into B, resulting in an extended policy language E. We showed that ReBAC policies deﬁnable in E are owner-checkable policies, a superset of relational policies. We also showed that every ﬁnitary relational policy is deﬁnable in E, meaning that E is representationally complete with respect to that policy family. We have therefore identiﬁed a policy language that is representationally adequate for expressing useful ReBAC policies.
Acknowledgements
This work is supported in part by an NSERC Discovery Accelerator Supplements.
8. REFERENCES
[1] M. Anwar, Z. Zhao, and P. W. L. Fong. An access control model for Facebook-style social network systems. Tech. Rep. 2010-959-08, Dept. of Computer Science, University of Calgary, AB, Canada, July 2010.
[2] F. Baader, D. Calvanese, D. L. McGuinness, D. Nardi, and P. F. Patel-Schneider, editors. The Description Logic Handbook. Cambridge, 2007.
[3] L. Badger, D. F. Sterne, D. L. Sherman, K. M. Walker, and S. A Haghighat. Practical domain and type enforcement for UNIX. In Proceedings of the 1995 IEEE Symposium on Security and Privacy (S&P’95), pages 66–77, Oakland, CA, USA, May 1995.
[4] M. Y. Becker and P. Sewell. Cassandra: Flexible trust management, applied to electronic health records. In Proceedings of the 17th IEEE Computer Security Foundations Workshop (CSFW’04), Paciﬁc Grove, CA, USA, June 2004.
[5] K. Beznosov. Requirements for access control: US healthcare domain. In Proceedings of the 3rd ACM Workshop on Role-Based Access Control (RBAC’98), page 43, Fairfax, VA, USA, October 1998.
[6] P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Cambridge, 2001.
[7] M. Blaze, J. Feigenbaum, and J. Lacy. Decentralized trust management. In Proceedings of the 1996 IEEE Symposium on Security and Privacy (S&P’96), pages 164–173, Oakland, CA, USA, May 1996.
[8] B. Carminati, E. Ferrari, R. Heatherly, M. Kantarcioglu, and B. Thurainsingham. A semantic web based framework for social network access control. In Proceedings of the 14th ACM Symposium on Access Control Models and Technologies (SACMAT’09), pages 177–186, Stresa, Italy, June 2009.

58

[9] B. Carminati, E. Ferrari, and A. Perego. Enforcing access control in Web-based social networks. ACM Transactions on Information and System Security, 13(1):1–38, October 2009.
[10] D. Chakrabarti and C. Faloutsos. Graph mining: Laws, generators, and algorithms. ACM Computing Surveys, 38, March 2006.
[11] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algorithms. MIT Press, 3rd edition, 2009.
[12] D. F. Ferraiolo, R. Sandhu, S. Gavrila, D. R. Kuhn, and R. Chandramouli. Proposed NIST standard for role-based access control. ACM Transactions on Information and System Security, 4(3):224–274, 2001.
[13] P. W. L. Fong. Access control by tracking shallow execution history. In Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04), pages 43–55, Oakland, CA, USA, May 2004.
[14] P. W. L. Fong. Preventing Sybil attacks by privilege attenuation: A design principle for social network systems. In Proceedings of the 2011 IEEE Symposium on Security and Privacy (S&P’11), Oakland, CA, USA, May 2011.
[15] P. W. L. Fong. Relationship-based access control: Protection model and policy language. In Proceedings of the First ACM Conference on Data and Application Security and Privacy (CODASPY’11), pages 191–202, San Antonio, Taxas, USA, February 2011.
[16] P. W. L. Fong, M. Anwar, and Z. Zhao. A privacy preservation model for Facebook-style social network systems. In Proceedings of the 14th European Symposium on Research In Computer Security (ESORICS’09), volume 5789 of LNCS, pages 303–320, Saint Malo, France, September 2009. Springer.
[17] Carrie E. Gates. Access Control Requirements for Web 2.0 Security and Privacy. In IEEE Web 2.0 Privacy and Security Workship (W2SP’07), Oakland, CA, USA, 2007.
[18] F. Giunchiglia, R. Zhang, and B. Crispo. RelBAC: Relation based access control. In Proceedings of the Fourth International Conference on Semantics, Knowledge and Grid (SKG’08), pages 3–11, Beijing, China, December 2008.
[19] L. Giuri and P. Iglio. Role templates for content-based access control. In Proceedings of the 2nd ACM Workshop on Role-Based Access Control (RBAC’97), pages 153–159, Fairfax, VA, USA, November 1997.
[20] V. Haarslev and R. M¨oller. RACER system description. In Proceedings of the 1st International Joint Conference on Automated Reasoning (IJCAR’01), pages 701–705, Siena, Italy, 2001.
[21] K. W. Hamlen, G. Morrisett, and F. B. Schneider. Computability classes for enforcement mechanisms. ACM Transactions on Programming Langanguages And Systems, 28(1):175–205, January 2006.
[22] I. R. Horrocks. Using an expressive description logic: FaCT or ﬁction? In Proceedings of the 6th International Conference on Principles of Knowledge Representation and Reasoning (KR’98), pages 636–649, Trento, Italy, 1998.
[23] S. R. Kruk, S. Grzonkowski, A. Gzella, T. Woroniecki, and H.-C. Choi. D-FOAF: Distributed identity

management with access rights delegation. In Proceedings of the 1st Asian Semantic Web Conference (ASWC’06), volume 4185 of LNCS, pages 140–154, Beijing, China, September 2006. Springer.
[24] N. Li, B. N. Grosof, and J. Feigenbaum. Delegation logic: A logic-based approach to distributed authorization. ACM Transactions on Information and System Security, 6(1):128–171, February 2003.
[25] N. Li, J. C. Mitchell, and W. H. Winsborough. Design of a role-based trust-management framework. In Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P’02), pages 114–130, Berkeley, California, USA, May 2002.
[26] J. Ligatti, L. Bauer, and D. Walker. Edit automata: Enforcement mechanisms for run-time security policies. International Journal of Information Security, 4(1–2):2–16, February 2005.
[27] J. Ligatti, L. Bauer, and D. Walker. Run-time enforcement of nonsafety policies. ACM Transactions on Information and Systems Security, 12(3), 2009.
[28] J. Ligatti and S. Reddy. A theory of runtime enforcement, with results. In Proceedings of the 15th European Symposium on Research in Computer Security (ESORICS’10), volume 6345 of LNCS, Athens, Greece, September 2010. Springer.
[29] E. Lupu and M. Sloman. Reconciling role based management and role based access control. In Proceedings of the 2nd ACM Workshop on Role-Based Access Control (RBAC’97), pages 135–141, Fairfax, VA, USA, November 1997.
[30] L. Rostad and O. Edsberg. A study of access control requirements for healthcare systems based on audit trails from access logs. In Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC’06), Miami Beach, FL, USA, December 2006.
[31] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman. Role-based access control models. IEEE Computer, 19(2):38–47, February 1996.
[32] K. Schild. A correspondence theory for terminological logics: preliminary report. In Proceedings of the 12th International Joint Conference on Artiﬁcial intelligence (IJCAI’91), pages 466–471, 1991.
[33] F. B. Schneider. Enforceable security policies. ACM Transactions on Information and System Security, 3(1):30–50, 2000.
[34] A. Squicciarini, F. Paci, and S. Sundareswaran. PriMa: An eﬀective privacy protection mechanism for social networks. In Proceedings of the 5th ACM Symposium on Information, Computer and Communications Security (ASIACCS’10), pages 320–323, Beijing, China, April 2010.
[35] A. C. Squicciarini, M. Shehab, and J. Wede. Privacy policies for shared content in social network sites. The VLDB Journal, 2010. To appear.
[36] C. Talhi, N. Tawbi, and M. Debbabi. Execution monitoring enforcement under memory-limitation constraints. Information and Computation, 206:158–184, 2008.
[37] S. Weeks. Understanding trust management systems. In Proceedings of the 2001 IEEE Symposium on Security and Privacy (S&P’01), pages 94–105, Oakland, California, USA, May 2001.

59

[38] R. Zhang, F. Giunchiglia, B. Crispo, and L. Song. Relation-based access control: An access control model for context-aware computing environment. Wireless Personal Communications, 55(1):5–17, September 2010.
APPENDIX
A. PROOF
Proposition 12. A relational policy is both OC and AC.
Proof. Suppose P is a relational policy. We show that P is OC. (The proof of the assertion that P is also AC is symmetrical.) Consider the social network G and vertices u, v ∈ V (G). It is obvious that CG(u; v) ⊆ G. There is no i ∈ I such that Ri (G)\Ri (CG(u; v)) contains a pair (u , v ) for which each of u and v is connected to u in G. Consequently, by Deﬁnition 5, P (CG(u; v))\P (G)∪P (G)\P (CG(u; v)) is an empty set, and thus P (G)(u, v) ⇔ P (CG(u; v))(u, v).
Theorem 13. A policy deﬁnable in E is OC.
Proof. Had it not been for the construct @p.φ, this theorem could have been proven in a straightforward manner via structural induction on the abstract syntax tree of a formula. The subtlety arises from the fact that φ may contain free occurrences of variables.
To address the presence of free variables, we prove a claim regarding a pair (Σ, φ), where Σ is an environment, and φ is a formula. A formula φ is said to be Σ-closed iﬀ every free variable of φ belongs to the domain of Σ. A pair (Σ, φ) is a closure iﬀ φ is Σ-closed. We also write π(Σ) to denote the environment Σ deﬁned over the same domain as Σ, such that Σ (p) = π(Σ(p)).
Claim: Given a closure (Σ, φ) such that Σ(a) is deﬁned, the following conditions hold:
1. Let π be an isomorphism between social networks G and G . Then G, Σ, u φ iﬀ G , π(Σ), π(u) φ.
2. G, Σ, u φ iﬀ CG(u; Σ(a)), Σ, u φ.
The theorem follows directly from the above claim. The proof of the claim is a straightforward structural induction on the abstract syntax tree of the formula in the closure.
The proof of Theorem 20 relies on the following lemma.
Lemma 23. Suppose P is both positive and OC. Let B be the minimal set of birooted graphs to positively induce P . For all G(u,v) ∈ B, every v ∈ V (G)\{v} is connected to u.
The proof of the lemma is elementary.
Theorem 20. Every ﬁnitary OC policy is deﬁnable in E.
Proof. We describe a sketch of the proof. Suppose P is a ﬁnitary OC policy. As P is positive, let B be the minimal set of birooted graphs to positively induce P . Since P is ﬁnitary, B is ﬁnite. We outline in the following the construction of an E formula φ for each birooted graph G(u,v) ∈ B such that, for every G (u ,v ) ∈ B(U, I), G(u,v) G (u ,v ) implies G , u , v |=E φ. The formula required by the theorem is the disjunction of the constructed formulas (recall that there are only ﬁnitely many of such formulas as B is ﬁnite).
Given birooted graph G(u,v) ∈ B, we construct a corresponding formula φ(u) as follows:

Step 1: We label each vertex by a distinct propositional symbol. (Since we have countably inﬁnitely many propositional symbols, we always have enough symbols to work with.) In the following, we write px for the propositional symbol associated with a vertex x.
Step 2: Since P is both positive and OC, Lemma 23 implies that the vertices in G (perhaps with the exception of v) are connected to u. With u as the root, one can therefore build a depth-ﬁrst search tree T . We assume that the search algorithm may traverse either along or against the direction of an edge. That is, a tree edge linking a parent vertex and a child vertex may go in either direction. Following standard terminology, we call the non-tree edges in G back edges. A back edge always link a descendent vertex with an ancestor vertex. (Again, a back edge may either point from a descendent vertex to an ancestor vertex, or point the other direction.) For more details regarding DFS trees, consult a standard text such as [11]. Note that v may or may not be part of T , but all other vertices are in T . Also, every edge in G is either a tree edge or a back edge.
Step 3: For each vertex x in search tree T , construct a formula φ(x) = ψ1 ∧ ψ2 ∧ @px.(ψ3 ∧ ψ4), where:
• If x is not the root of T (i.e., x = u), then ψ1 = ¬px1 ∧ ¬px2 ∧ . . . ∧ pxk , where x1, x2, . . . , xk are the proper ancestors of x (i.e., excluding x itself). In case x = u, then ψ1 = .
• If x = v, then ψ2 = a. Otherwise, ψ2 = ¬a.
• If x is a leaf of T , then ψ3 = . Otherwise, a subformula is constructed for each child of x in T . Suppose (x, y) ∈ Ri (G) is a tree edge linking x with its child y in T . The subformula corresponding to y is i φ(y). If the tree edge points in the other direction (i.e., (y, x) ∈ Ri (G)), then we use −i instead. Let ψ31, ψ32, . . . , ψ3m be the subformulas constructed in this way. We construct ψ3 = ψ31 ⊗ ψ32 ⊗ . . . ⊗ ψ3m.
• If x is not incident on a back edge in G, then ψ4 = . Otherwise, ψ4 is a conjunction of formulas, one for each back edge linking x with one of its ancestors. Suppose (x, y) ∈ Ri (G) is one such back edge. The conjunct corresponding to this back edge is i py. If the back edge points in the other direction (i.e., (y, x) ∈ Ri (G)), then we use −i instead.
The construction proceeds recursively, with φ(y) constructed prior to φ(x) whenever y is a child of x. The recursion terminates properly because T is a tree of ﬁnite size. The intuition behind the construction is that φ(u) is an encoding of G, including both the subgraph T and all the back edges. More precisely, φ(u) encodes a DFS that an authorization procedure can deploy to conﬁrm that a birooted graph contains a subgraph isomorphic to the “pattern” G(u,v). The detailed proof of this last claim is mechanical.

60

